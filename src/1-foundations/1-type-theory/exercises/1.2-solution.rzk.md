# Solution to exercise 1.2

This is a literate Rzk file:

```rzk
#lang rzk-1
```

Derive the recursion principle for products
$rec_{A \times B}$ using only the projections,
and verify that the definitional equalities are valid.
Do the same for $\Sigma$-types.

## Solution

### Product $A \times B$

In this solution, we use `prod`, defined earlier in [chapter 1.5](../05-product-types.rzk.md).

Introducing constructor for values of `prod` type:
```rzk
#def pair
  (A B : U)
  : A -> B -> prod A B
  := \ a b -> (a, b)
```

Projections were also defined in [chapter 1.5](../05-product-types.rzk.md) (`pr₁`, `pr₁`).

Type of the recursor on $A \times B$ is 
$$
rec_{A \times B}: \prod_{C:\mathcal{U}} (A \rightarrow B \rightarrow C) \rightarrow A \times B \rightarrow C
$$
Defining it through projections:
```rzk
#def prod-rec-via-projections
  (A B : U)
  (C : U)
  : (g : A -> B -> C) -> (p : prod A B) -> C
  := \ g p -> g (pr₁-via-recursor A B p) (pr₂-via-recursor A B p)
```

Definitions in another way were already provided in [chapter 1.5](../05-product-types.rzk.md) (`pr₁-via-recursor`, `pr₂-via-recursor`)

Checking definitional equalities:

Recursion from projections:
```rzk
#def prod-rec-via-projections-works
  (A B C : U)
  (g : A -> B -> C)
  (a : A)
  (b : B)
  : prod-rec-via-projections A B C g (pair A B a b) = g a b
  := refl
```
Projections from the recursion:
```rzk
#def pr₁-via-recursor-works
  (A B : U)
  (a : A)
  (b : B)
  : pr₁-via-recursor A B (pair A B a b) = a
  := refl

#def pr₂-from-recursor-works
  (A B : U)
  (a : A)
  (b : B)
  : pr₂-via-recursor A B (pair A B a b) = b
  := refl
```

###  Dependant pairs

Sigma types are built-in, so we head right into the exercise.

Defining projections and recursion
```rzk
#def pr₁-sigma
  (A : U)
  (B : A -> U)
  : (Sigma (x : A), (B x)) -> A
  := \p -> first p

#def pr₂-sigma
  (A : U)
  (B : A -> U)
  : (p : Sigma (x : A), (B x)) -> (B (first p))
  := \p -> second p
```

Recursor for sigma types. They look like this:
$$
rec_{\Sigma_{x : A}B(x)} ((C: U), (g: (x : A) \rightarrow B (x) \rightarrow C), (p: \Sigma_{x : A} B(x)))
$$
```rzk
#def rec-sigma
  (A : U)
  (B : A -> U)
  (C : U)
  : (g : (x : A) -> B x -> C) -> (p : Sigma (x : A), (B x)) -> C
  := \ g p -> g (pr₁-sigma A B p) (pr₂-sigma A B p)
```

(Extra, not in the task) Other way around:
```rzk
#def rec-sigma-reversed
  (A : U)
  (B : A -> U)
  (C : U)
  : (g : (x : A) -> B x -> C) -> (p : Sigma (x : A), (B x)) -> C
  := \ g (a, b) -> g a b

#def pr₁-sigma-reversed
  (A : U)
  (B : A -> U)
  : (Sigma (x : A), (B x)) -> A
  := \p -> rec-sigma-reversed A B A (\ x y -> x) p
```

For the second projection ($pr_2$) we need the induction:
```rzk
#def ind-sigma-reversed
  (A : U)
  (B : A -> U)
  (C : (Sigma (x : A), (B x)) -> U)
  : (g : (x : A) -> (y : B x) -> C (x, y)) -> (p : Sigma (x : A), (B x)) -> C p
  := \ g (a, b) -> g a b

#def pr₂-sigma-reversed
  (A : U)
  (B : A -> U)
  : (p : Sigma (x : A), (B x)) -> (B (pr₁-sigma-reversed A B p))
  := \p -> ind-sigma-reversed A B (\ p1 -> B (pr₁-sigma-reversed A B p1)) (\ x y -> y) p
```

Checking the definitional equalities

```rzk
#def rec-sigma-works
  (A : U)
  (B : A -> U)
  (C : U)
  (g : (x : A) -> B x -> C)
  (a : A)
  (b : B a)
  : rec-sigma A B C g (a, b) = g a b
  := refl

#def pr₁-sigma-works
  (A : U)
  (B : A -> U)
  (a : A)
  (b : B a)
  : pr₁-sigma A B (a, b) = a
  := refl

#def pr₂-sigma-works
  (A : U)
  (B : A -> U)
  (a : A)
  (b : B a)
  : pr₂-sigma A B (a, b) = b
  := refl
```
