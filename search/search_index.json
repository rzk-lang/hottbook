{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HoTT Book formalisations in Rzk \u00b6 This project contains formalisations that follow the HoTT Book . How to check \u00b6 From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"General"},{"location":"#hott-book-formalisations-in-rzk","text":"This project contains formalisations that follow the HoTT Book .","title":"HoTT Book formalisations in Rzk"},{"location":"#how-to-check","text":"From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"How to check"},{"location":"1-foundations/1-type-theory/4-dependent-function-types.rzk/","text":"1.4 Dependent function types ( \\(\\Pi\\) -types) \u00b6 This is a literate Rzk file: #lang rzk-1 A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function: #define id ( A : U) : A \u2192 A := \\ x \u2192 x Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function: #define swap ( A B C : U) : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C) := \\ f y x \u2192 f x y","title":"1.4 Dependent function types"},{"location":"1-foundations/1-type-theory/4-dependent-function-types.rzk/#14-dependent-function-types-pi-types","text":"This is a literate Rzk file: #lang rzk-1 A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function: #define id ( A : U) : A \u2192 A := \\ x \u2192 x Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function: #define swap ( A B C : U) : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C) := \\ f y x \u2192 f x y","title":"1.4 Dependent function types (\\(\\Pi\\)-types)"},{"location":"1-foundations/1-type-theory/5-product-types.rzk/","text":"1.5 Product types \u00b6 This is a literate Rzk file: #lang rzk-1 Rzk has built-in support for dependent pairs, so we define product types here in terms of those. #define prod ( A B : U) : U := \u03a3 ( _ : A), B To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\) -types: (a, b) . To use a pair, we can use pattern matching or introduce projections: #define pr\u2081 ( A B : U) : prod A B \u2192 A := \\ (a, _b) \u2192 a #define pr\u2082 ( A B : U) : prod A B \u2192 B := \\ (_a, b) \u2192 b The recursor for product types can be defined as follows: #define prod-rec ( A B : U) : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C := \\ C f (a, b) \u2192 f a b Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define #define pr\u2081' ( A B : U) : prod A B \u2192 A := prod-rec A B A ( \\ a _b \u2192 a) #define pr\u2082' ( A B : U) : prod A B \u2192 B := prod-rec A B B ( \\ _a b \u2192 b) To be able to define dependent functions over the product type, we have to generalize the recursor: #define prod-ind ( A B : U) : ( C : prod A B \u2192 U) \u2192 ( (x : A) \u2192 ( y : B) \u2192 C (x, y)) \u2192 ( x : prod A B) \u2192 C x := \\ C f (x, y) \u2192 f x y For example, in this way we can prove the propositional uniqueness principle, which says that every element of A \u00d7 B is equal to a pair. Specifically, we can construct a function #define prod-uniq ( A B : U) : ( x : prod A B) \u2192 (pr\u2081 A B x, pr\u2082 A B x) =_{prod A B} x := \\ (a, b) \u2192 refl _{(a, b)} Unit type \u00b6 Rzk has a built-in Unit type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book. Still, following the book, here is the recursor for the unit type: #define Unit-rec : ( C : U) \u2192 C \u2192 Unit \u2192 C := \\ _C c _unit \u2192 c And, similarly, the induction principle for the unit type: #define Unit-ind : ( C : Unit \u2192 U) \u2192 C unit \u2192 ( x : Unit) \u2192 C x := \\ _C c unit \u2192 c Induction enables us to prove the propositional uniqueness principle for Unit , which asserts that its only inhabitant is unit : #define Unit-uniq : ( x : Unit) \u2192 x = unit := Unit-ind ( \\ x \u2192 x = unit ) refl _{ unit } As mentioned above, this uniqueness principle is built into Rzk (making any value of type Unit definitionally equal to unit ), allowing to use refl immediately: #define Unit-uniq' : ( x : Unit) \u2192 x = unit := \\ _ \u2192 refl","title":"1.5 Product types"},{"location":"1-foundations/1-type-theory/5-product-types.rzk/#15-product-types","text":"This is a literate Rzk file: #lang rzk-1 Rzk has built-in support for dependent pairs, so we define product types here in terms of those. #define prod ( A B : U) : U := \u03a3 ( _ : A), B To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\) -types: (a, b) . To use a pair, we can use pattern matching or introduce projections: #define pr\u2081 ( A B : U) : prod A B \u2192 A := \\ (a, _b) \u2192 a #define pr\u2082 ( A B : U) : prod A B \u2192 B := \\ (_a, b) \u2192 b The recursor for product types can be defined as follows: #define prod-rec ( A B : U) : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C := \\ C f (a, b) \u2192 f a b Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define #define pr\u2081' ( A B : U) : prod A B \u2192 A := prod-rec A B A ( \\ a _b \u2192 a) #define pr\u2082' ( A B : U) : prod A B \u2192 B := prod-rec A B B ( \\ _a b \u2192 b) To be able to define dependent functions over the product type, we have to generalize the recursor: #define prod-ind ( A B : U) : ( C : prod A B \u2192 U) \u2192 ( (x : A) \u2192 ( y : B) \u2192 C (x, y)) \u2192 ( x : prod A B) \u2192 C x := \\ C f (x, y) \u2192 f x y For example, in this way we can prove the propositional uniqueness principle, which says that every element of A \u00d7 B is equal to a pair. Specifically, we can construct a function #define prod-uniq ( A B : U) : ( x : prod A B) \u2192 (pr\u2081 A B x, pr\u2082 A B x) =_{prod A B} x := \\ (a, b) \u2192 refl _{(a, b)}","title":"1.5 Product types"},{"location":"1-foundations/1-type-theory/5-product-types.rzk/#unit-type","text":"Rzk has a built-in Unit type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book. Still, following the book, here is the recursor for the unit type: #define Unit-rec : ( C : U) \u2192 C \u2192 Unit \u2192 C := \\ _C c _unit \u2192 c And, similarly, the induction principle for the unit type: #define Unit-ind : ( C : Unit \u2192 U) \u2192 C unit \u2192 ( x : Unit) \u2192 C x := \\ _C c unit \u2192 c Induction enables us to prove the propositional uniqueness principle for Unit , which asserts that its only inhabitant is unit : #define Unit-uniq : ( x : Unit) \u2192 x = unit := Unit-ind ( \\ x \u2192 x = unit ) refl _{ unit } As mentioned above, this uniqueness principle is built into Rzk (making any value of type Unit definitionally equal to unit ), allowing to use refl immediately: #define Unit-uniq' : ( x : Unit) \u2192 x = unit := \\ _ \u2192 refl","title":"Unit type"}]}