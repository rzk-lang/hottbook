{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HoTT Book formalisations in Rzk","text":"<p>This project contains formalisations that follow the HoTT Book.</p>"},{"location":"#how-to-check","title":"How to check","text":"<p>From the root of the project's repository, run:</p> <pre><code>rzk typecheck src/**/*.rzk.md\n</code></pre>"},{"location":"1-foundations/0-chapter-template/01-section.rzk/","title":"0.1 Section name","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>References to the sections within the chapter should also be added to <code>mkdocs.yml</code></p>"},{"location":"1-foundations/0-chapter-template/02-section.rzk/","title":"0.2 Section name","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/","title":"Solution to exercise 0.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/","title":"Solution to exercise 0.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/04-dependent-function-types.rzk/","title":"1.4 Dependent function types (\\(\\Pi\\)-types)","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function:</p> <pre><code>#define id\n( A : U)\n  : A \u2192 A\n  := \\ x \u2192 x\n</code></pre> <p>Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function:</p> <pre><code>#define swap\n( A B C : U)\n  : ( A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\n  := \\ f y x \u2192 f x y\n</code></pre>"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/","title":"1.5 Product types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Rzk has built-in support for dependent pairs, so we define product types here in terms of those.</p> <pre><code>#define prod (A B : U)\n  : U\n  := \u03a3 (_ : A) , B\n</code></pre> <p>To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\)-types: <code>(a, b)</code>.</p> <p>To use a pair, we can use pattern matching or introduce projections:</p> <pre><code>#define pr\u2081\n( A B : U)\n  : prod A B \u2192 A\n  := \\ (a , _b) \u2192 a\n#define pr\u2082\n( A B : U)\n  : prod A B \u2192 B\n  := \\ (_a , b) \u2192 b\n</code></pre> <p>The recursor for product types can be defined as follows:</p> <pre><code>#define prod-rec\n( A B : U)\n  : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C\n  := \\ C f (a , b) \u2192 f a b\n</code></pre> <p>Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define</p> <pre><code>#define pr\u2081-via-rec\n( A B : U)\n  : prod A B \u2192 A\n  := prod-rec A B A (\\ a _b \u2192 a)\n#define pr\u2082-via-rec\n( A B : U)\n  : prod A B \u2192 B\n  := prod-rec A B B (\\ _a b \u2192 b)\n</code></pre> <p>To be able to define dependent functions over the product type, we have to generalize the recursor:</p> <pre><code>#define prod-ind\n( A B : U)\n  : ( C : prod A B \u2192 U) \u2192 ((x : A) \u2192 (y : B) \u2192 C (x , y)) \u2192 (x : prod A B) \u2192 C x\n  := \\ C f (x , y) \u2192 f x y\n</code></pre> <p>For example, in this way we can prove the propositional uniqueness principle, which says that every element of <code>A \u00d7 B</code> is equal to a pair. Specifically, we can construct a function</p> <pre><code>#define prod-uniq\n( A B : U)\n  : ( x : prod A B) \u2192 (pr\u2081 A B x , pr\u2082 A B x) =_{prod A B} x\n  := \\ (a , b) \u2192 refl_{(a , b)}\n</code></pre>"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/#unit-type","title":"Unit type","text":"<p>Rzk has a built-in <code>Unit</code> type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book.</p> <p>Still, following the book, here is the recursor for the unit type:</p> <pre><code>#define Unit-rec\n  : ( C : U) \u2192 C \u2192 Unit \u2192 C\n  := \\ _C c _unit \u2192 c\n</code></pre> <p>And, similarly, the induction principle for the unit type:</p> <pre><code>#define Unit-ind\n  : ( C : Unit \u2192 U) \u2192 C unit \u2192 (x : Unit) \u2192 C x\n  := \\ _C c unit \u2192 c\n</code></pre> <p>Induction enables us to prove the propositional uniqueness principle for <code>Unit</code>, which asserts that its only inhabitant is <code>unit</code>:</p> <pre><code>#define Unit-uniq\n  : ( x : Unit) \u2192 x = unit\n  := Unit-ind (\\ x \u2192 x = unit) refl_{unit}\n</code></pre> <p>As mentioned above, this uniqueness principle is built into Rzk (making any value of type <code>Unit</code> definitionally equal to <code>unit</code>), allowing to use <code>refl</code> immediately:</p> <pre><code>#define Unit-uniq'\n  : ( x : Unit) \u2192 x = unit\n  := \\ _ \u2192 refl\n</code></pre>"},{"location":"1-foundations/1-type-theory/06-dependent-pair-types.rzk/","title":"1.6 Dependent pair types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>TODO</p> <p>Add proper descriptions and check for missing definitions</p> <p><pre><code>#def pr\u2081-\u03a3\n( A : U)\n( B : A \u2192 U)\n  : ( \u03a3 ( x : A) , B x) \u2192 A\n  := \\ p \u2192 first p\n#def pr\u2082-\u03a3\n( A : U)\n( B : A \u2192 U)\n  : ( p : \u03a3 (x : A) , B x) \u2192 (B (first p))\n  := \\ p \u2192 second p\n</code></pre> Recursor for \\(\\Sigma\\)-types. They are called like this:</p> \\[ \\mathsf{rec}_{\\Sigma_{x : A}B(x)} ((C: U), (g: (x : A) \\rightarrow B (x) \\rightarrow C), (p: \\Sigma_{x : A} B(x))) \\] <pre><code>#def rec-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : U)\n  : ( g : (x : A) \u2192 B x \u2192 C) \u2192 (p : \u03a3 (x : A) , B x) \u2192 C\n  := \\ g (a , b) \u2192 g a b\n</code></pre> <pre><code>#def ind-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (\u03a3 (x : A) , B x) \u2192 U)\n  : ( g : (x : A) \u2192 (y : B x) \u2192 C (x , y)) \u2192 (p : \u03a3 (x : A) , B x) \u2192 C p\n  := \\ g (a , b) \u2192 g a b\n</code></pre>"},{"location":"1-foundations/1-type-theory/07-coproduct-types.rzk/","title":"1.7 Coproduct types","text":"<p>Warning</p> <p>Coproduct types are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/08-booleans.rzk/","title":"1.8 The type of booleans","text":"<p>Warning</p> <p>Booleans are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/09-natural-numbers.rzk/","title":"1.9 The natural numbers","text":"<p>Warning</p> <p>Natural numbers (and user-defined data types) are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/10-pattern-matching-and-recursion.rzk/","title":"1.10 Pattern matching and recursion","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/11-propositions-as-types.rzk/","title":"1.11 Propositions as types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/12-identity-types.rzk/","title":"1.11 Identity types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Induction on identity type is defined with built-in <code>idJ</code> operator:</p> <pre><code>#def path-ind\n( A : U)\n( C : (x : A) \u2192 (y : A) \u2192 (x = y) \u2192 U)\n( d : (x : A) \u2192 C x x refl)\n  : ( x : A) \u2192 (y : A) \u2192 (p : x = y) \u2192 C x y p\n  := \\ x y p \u2192 idJ(A , x , C x , d x , y , p)\n</code></pre> <p>Indiscernability of identicals:</p> <pre><code>#def indiscernability-of-identicals\n( A : U)\n( C : A \u2192 U)\n  : ( x : A) \u2192 (y : A) \u2192 (p : x = y) \u2192 (C x) \u2192 (C y)\n  := path-ind\n    A\n    ( \\ x y p \u2192 ((C x) \u2192 (C y)))\n    ( \\ x \u2192 \\ cx \u2192 cx)\n</code></pre> <p>Based path induction directly corresponds to the <code>idJ</code> operator:</p> <pre><code>#def based-path-ind\n( A : U)\n( a : A)   \n( C : (x : A) \u2192 (a = x) \u2192 U)\n( ca : C a refl)\n  : ( x : A) \u2192 (p : a = x) \u2192 (C x p)\n  := \\ x p \u2192 idJ(A , a , C , ca , x , p)\n</code></pre> <p>Based path induction can be defined with the (usual) path induction:</p> <pre><code>#def based-path-ind'\n( A : U)\n  : ( a : A)\n  \u2192 ( C : (x : A) \u2192 (a = x) \u2192 U)\n  \u2192 ( ca : C a refl)\n  \u2192 ( x : A)\n  \u2192 ( p : a = x)\n  \u2192 ( C x p)\n  := \\ a C ca x p \u2192 \n  path-ind \n    A\n( \\ a' x' p' \u2192 (C' : ((x'' : A) \u2192 (a' = x'') \u2192 U)) \u2192 (C' a' refl) \u2192 (C' x' p'))\n    ( \\ a' \u2192 \\ C' ca' \u2192 ca')\n    a x p C ca\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/","title":"Exercises for Section 1","text":""},{"location":"1-foundations/1-type-theory/exercises/#exercise-11","title":"Exercise 1.1","text":"<p>Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\), define their composite \\(g \\circ f : A \\to C\\). Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\).</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-12","title":"Exercise 1.2","text":"<p>Derive the recursion principle for products \\(rec_{A \\times B}\\) using only the projections, and verify that the definitional equalities are valid. Do the same for \\(\\Sigma\\)-types.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-13","title":"Exercise 1.3","text":"<p>Derive the induction principle for products \\(ind_{A \\times B}\\), using only the projections and the propositional uniqueness principle \\(uniq_{A \\times B}\\). Verify that the definitional equalities are valid. Generalize \\(uniq_{A \\times B}\\) to \\(\\Sigma\\)-types, and do the same for \\(\\Sigma\\)-types. (This requires concepts from Chapter 2.)</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-14","title":"Exercise 1.4","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-15","title":"Exercise 1.5","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-16","title":"Exercise 1.6","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-17","title":"Exercise 1.7","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-18","title":"Exercise 1.8","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-19","title":"Exercise 1.9","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-110","title":"Exercise 1.10","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-111","title":"Exercise 1.11","text":"<p>Show that for any type \\(A\\), we have \\(\\lnot \\lnot \\lnot A \\to \\lnot A\\).</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-112","title":"Exercise 1.12","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-113","title":"Exercise 1.13","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-114","title":"Exercise 1.14","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-115","title":"Exercise 1.15","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-116","title":"Exercise 1.16","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/","title":"Solution to exercise 1.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.1</p> <p>Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\), define their composite \\(g \\circ f : A \\to C\\). Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\).</p>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/#solution","title":"Solution","text":"<p>First, the definition of the composition operation is provided as:</p> \\[ g \\circ f :\\equiv \\lambda (x: A) . g(f(x)) \\] <p>Then, associativity can be demonstrated by evaluating both sides of the equality and reaching the same result:</p> \\[     \\begin{align*}         h \\circ (g \\circ f) &amp; \\equiv \\lambda x. h((g\\circ f)(x)) \\\\                             &amp; \\equiv \\lambda x. h((\\lambda x' . g(f(x'))) (x)) \\\\                             &amp; \\equiv \\lambda x. h(g(f(x)))     \\end{align*} \\] \\[     \\begin{align*}         (h \\circ g) \\circ f &amp; \\equiv \\lambda x. (h\\circ g)(f(x)) \\\\                             &amp; \\equiv \\lambda x. (\\lambda y . h(g(y)))(f(x)) \\\\                             &amp; \\equiv \\lambda x. h(g(f(x)))     \\end{align*} \\] <p>This can be represented in rzk like so:</p> <pre><code>#define compose\n( A B C : U)\n( g : B \u2192 C)\n( f : A \u2192 B)\n  : A \u2192 C\n  := \\ x \u2192 g (f x)\n</code></pre> <p>Associativity is automatic (by <code>refl</code>):</p> <pre><code>#define composition-associativity\n( A B C D : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( h : C \u2192 D)\n  : compose A C D h (compose A B C g f) = compose A B D (compose B C D h g) f\n  := refl\n</code></pre> <p>An explicit proof (not checked by <code>rzk</code>):</p> <pre><code>compose A C D h (compose A B C g f)\n= \\ x \u2192 h ((compose A B C g f) x)       (unfolding compose)\n= \\ x \u2192 h ((\\ x2 \u2192 g (f x2)) x)         (unfolding compose)\n= \\ x \u2192 h (g (f x))                     (beta reduction)\n= \\ x \u2192 (\\ x2 \u2192 h (g x2)) (f x)         (beta reduction)\n= \\ x \u2192 (compose B C D h g) (f x)       (fold compose)\n= compose A B D (compose B C D h g) f   (fold compose)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/","title":"Solution to exercise 1.10","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/","title":"Solution to exercise 1.11","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.11</p> <p>Show that for any type \\(A\\), we have \\(\u00ac\u00ac\u00acA \u2192 \u00acA\\).</p>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/#solution","title":"Solution","text":"<p>This is a weakened version of the double negation law and it holds constructively.</p> <p>Proposition \\(\\lnot X\\) corresponds to <code>(X \u2192 \u22a5)</code> type. We are given <code>f : (((A \u2192 \u22a5) \u2192 \u22a5) \u2192 \u22a5)</code> and <code>a : A</code> and we need to construct an element of type <code>\u22a5</code>. For that, we need to apply <code>f</code> to a term of type <code>((A \u2192 \u22a5) \u2192 \u22a5)</code>.  The term <code>\\ g \u2192 g a</code> has the required type.</p> <pre><code>#def triple-neg\n( A : U)\n  : ( ( ( A \u2192 \u22a5) \u2192 \u22a5) \u2192 \u22a5) \u2192 (A \u2192 \u22a5)\n  := \\ f a \u2192 f (\\ g \u2192 g a)\n</code></pre> <p>As the solution does not involve specifics of <code>\u22a5</code> type (in particular, that anything follows from it),  it is possible to generalise the solution to an arbitrary type <code>B</code> instead of <code>\u22a5</code>.</p> <pre><code>#def triple-neg'\n( A B : U)\n  : ( ( ( A \u2192 B) \u2192 B) \u2192 B) \u2192 (A \u2192 B)\n  := \\ f a \u2192 f (\\ g \u2192 g a)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/","title":"Solution to exercise 1.12","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/","title":"Solution to exercise 1.13","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/","title":"Solution to exercise 1.14","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/","title":"Solution to exercise 1.15","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/","title":"Solution to exercise 1.16","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/","title":"Solution to exercise 1.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.2</p> <p>Derive the recursion principle for products \\(\\mathsf{rec}_{A \\times B}\\) using only the projections, and verify that the definitional equalities are valid. Do the same for \\(\\Sigma\\)-types.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#solution-for-products","title":"Solution for products","text":"<p>In this solution, we use <code>prod</code> and projections (<code>pr\u2081</code> and <code>pr\u2082</code>), defined earlier in section 1.5.</p> <p>Introducing constructor for values of <code>prod</code> type:</p> <pre><code>#def pair\n( A B : U)\n  : A \u2192 B \u2192 prod A B\n  := \\ a b \u2192 (a , b)\n</code></pre> <p>The type of the recursor on \\(A \\times B\\) is</p> \\[ \\mathsf{rec}_{A \\times B}: \\prod_{C:\\mathcal{U}} (A \\to B \\to C) \\to A \\times B \\to C \\] <p>It can be defined using projection as such:</p> \\[ rec_{A\\times B}(C, g, x) :\\equiv g(\\mathsf{pr}_1(x))(\\mathsf{pr}_2(x)) \\] <p>And represented in rzk like so:</p> <pre><code>#def prod-rec-via-projections\n( A B : U)\n( C : U)\n( g : A \u2192 B \u2192 C)\n( p : prod A B)\n  : C\n  := g (pr\u2081 A B p) (pr\u2082 A B p)\n</code></pre> <p>Definitions of projections via recursion in the other direction (<code>pr\u2081-via-rec</code>, <code>pr\u2082-via-rec</code>) were already provided in section 1.5.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#checking-definitional-equalities","title":"Checking definitional equalities","text":"<p>Recursion from projections:</p> <pre><code>#def prod-rec-via-projections-works\n( A B C : U)\n( g : A \u2192 B \u2192 C)\n( a : A)\n( b : B)\n  : prod-rec-via-projections A B C g (pair A B a b) = g a b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p> <p>Projections from the recursion:</p> <pre><code>#def pr\u2081-via-rec-works\n( A B : U)\n( a : A)\n( b : B)\n  : pr\u2081-via-rec A B (pair A B a b) = a\n  := refl\n#def pr\u2082-from-rec-works\n( A B : U)\n( a : A)\n( b : B)\n  : pr\u2082-via-rec A B (pair A B a b) = b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#solution-for-dependant-pairs","title":"Solution for dependant pairs","text":"<p>Similarly, for \\(\\Sigma\\)-types, the recursion principle has the type:</p> \\[ \\mathsf{rec}_{\\Sigma_{x:A}B(x)} : \\Pi_{C:U}(\\Pi_{x:A} B(x) \\to C) \\to (\\Sigma_{x:A} B(x)) \\to C \\] <p>and can be defined using the projection functions as such:</p> \\[ \\mathsf{rec}_{\\Sigma_{x:A}B(x)}(C, g, x) :\\equiv g(\\mathsf{pr}_1(x))(\\mathsf{pr}_2(x)) \\] <p>\\(\\Sigma\\)-types are built-in. Also, <code>pr\u2081-\u03a3</code>, <code>pr\u2082-\u03a3</code>, <code>rec-\u03a3</code>, <code>ind-\u03a3</code> were already defined in section 1.6.</p> <p>Defining recursion from <code>pr\u2081-\u03a3</code> and <code>pr\u2082-\u03a3</code>:</p> <pre><code>#def rec-\u03a3-via-projections\n( A : U)\n( B : A \u2192 U)\n( C : U)\n( g : (x : A) \u2192 B x \u2192 C)\n( p : \u03a3 (x : A) , B x)\n  : C\n  := g (pr\u2081-\u03a3 A B p) (pr\u2082-\u03a3 A B p)\n</code></pre> <p>(Extra, not in the task) Other direction of definition (projecitons via recursion):</p> <pre><code>#def pr\u2081-\u03a3-via-rec\n( A : U)\n( B : A \u2192 U)\n  : ( \u03a3 ( x : A) , B x) \u2192 A\n  := rec-\u03a3 A B A (\\ x y \u2192 x)\n</code></pre> <p>For the second projection (\\(\\mathsf{pr}_2\\)) we need the induction, since the output type depends on \\(x : A\\):</p> <pre><code>#def pr\u2082-\u03a3-via-rec\n( A : U)\n( B : A \u2192 U)\n  : ( p : \u03a3 (x : A) , B x) \u2192 (B (pr\u2081-\u03a3-via-rec A B p))\n  := ind-\u03a3 A B (\\ p1 \u2192 B (pr\u2081-\u03a3-via-rec A B p1)) (\\ x y \u2192 y)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#checking-the-definitional-equalities","title":"Checking the definitional equalities","text":"<pre><code>#def rec-\u03a3-via-projections-works\n( A : U)\n( B : A \u2192 U)\n( C : U)\n( g : (x : A) \u2192 B x \u2192 C)\n( a : A)\n( b : B a)\n  : rec-\u03a3-via-projections A B C g (a , b) = g a b\n  := refl\n#def pr\u2081-\u03a3-via-rec-works\n( A : U)\n( B : A \u2192 U)\n( a : A)\n( b : B a)\n  : pr\u2081-\u03a3-via-rec A B (a , b) = a\n  := refl\n#def pr\u2082-\u03a3-via-rec-works\n( A : U)\n( B : A \u2192 U)\n( a : A)\n( b : B a)\n  : pr\u2082-\u03a3-via-rec A B (a , b) = b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/","title":"Solution to exercise 1.3","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Derive the induction principle for products \\(ind_{A \\times B}\\), using only the projections and the propositional uniqueness principle \\(uniq_{A \\times B}\\). Verify that the definitional equalities are valid. Generalize \\(uniq_{A \\times B}\\) to \\(\\Sigma\\)-types, and do the same for \\(\\Sigma\\)-types. (This requires concepts from Chapter 2.)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/#solution","title":"Solution","text":""},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/","title":"Solution to exercise 1.4","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/","title":"Solution to exercise 1.5","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/","title":"Solution to exercise 1.6","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/","title":"Solution to exercise 1.7","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/","title":"Solution to exercise 1.8","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/","title":"Solution to exercise 1.9","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/","title":"2.1 Types are higher groupoids","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Groupoids are categories in which all morphisms are isomorphisms. Alternativerly, groupoids can be viewed as a generalization of groups, where not all pairs of elements can be composed (but the group laws for the operation hold).</p>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#path-symmetry","title":"Path symmetry","text":"<p>Lemma 2.1.1. Symmetry / Inversion of paths / Inverse morphism</p> <p>For every type \\(A\\) and every \\(x, y : A\\) there is a function \\((x = y) \\to (y = x)\\) denoted \\(p \\mapsto p^{-1}\\), such that \\(\\mathsf{refl}_x^{-1} \\equiv \\mathsf{refl}_x\\) for each \\(x : A\\). We call \\(p^{-1}\\) the inverse of \\(p\\).</p> <pre><code>#def path-sym\n( A : U)\n( x y : A)\n  : ( x = y) \u2192 (y = x)\n  := path-ind\n    A\n    ( \\ x' y' _ \u2192 y' = x')\n    ( \\ z \u2192 refl)\n    x y\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#path-concatenation","title":"Path concatenation","text":"<p>Lemma 2.1.2. Transitivity / Path concatenation / Composition of morphisms</p> <p>For every type \\(A\\) and every \\(x, y, z : A\\) there is a function \\((x = y) \\to (y = z) \\to (x = z)\\), written \\(p \\mapsto q \\mapsto p \\cdot q\\), such that \\(\\mathsf{refl}_x \\cdot \\mathsf{refl}_x \\equiv \\mathsf{refl}_x\\) for any \\(x : A\\). We call \\(p \\cdot q\\) the concatenation or composite of \\(p\\) and \\(q\\).</p> <pre><code>#def path-concat\n( A : U)\n( x y z : A)\n  : ( x = y) \u2192 (y = z) \u2192 (x = z)\n  := \\ p \u2192 path-ind\n      A\n      ( \\ x' y' p' \u2192 ((y' = z) \u2192 (x' = z)))\n      ( \\ x' \u2192 \\ r \u2192 r)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#properties","title":"Properties","text":"<p>Lemma 2.1.4. Coherence laws</p> <p>Suppose \\(A : U\\), that \\(x, y, z, w : A\\) and that \\(p : x = y\\) and \\(q : y = z\\) and \\(r : z = w\\). We have the following:</p> <ol> <li>\\(p = p \\cdot \\mathsf{refl}\\) and \\(p=\\mathsf{refl} \\cdot p\\).</li> <li>\\(p^{-1} \\cdot p = \\mathsf{refl}\\) and \\(p \\cdot p^{-1} = \\mathsf{refl}\\).</li> <li>\\((p^{-1})^{-1} = p\\).</li> <li>\\(p \\cdot (q \\cdot r) = (p \\cdot q) \\cdot r\\).</li> </ol>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#composition-with-refl","title":"Composition with <code>refl</code>","text":"<pre><code>#def concat-refl\n( A : U)\n( x y : A)\n( p : x = y)\n  : p = path-concat A x y y p refl\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 p' = path-concat A x' y' y' p' refl)\n-- ? : refl = path-concat A x x x refl refl ==\n    ( \\ _ \u2192 refl)\n    x y p\n#def refl-concat\n( A : U)\n( x y : A)\n( p : x = y)\n  : p = path-concat A x x y refl p\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 p' = path-concat A x' x' y' refl p')\n-- ? : p = path-concat A x x x refl refl\n    ( \\ _ \u2192 refl)\n    x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#composition-with-inverse","title":"Composition with inverse","text":"<pre><code>#def inverse-l\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-concat A y x y (path-sym A x y p) p = refl\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 path-concat A y' x' y' (path-sym A x' y' p') p' = refl)\n    ( \\ _ \u2192 refl)\n    x y p\n#def inverse-r\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-concat A x y x p (path-sym A x y p) = refl\n  := path-ind A\n     ( \\ x' y' p' \u2192 path-concat A x' y' x' p' (path-sym A x' y' p') = refl)\n     ( \\ _ \u2192 refl)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#inverse-of-inverse","title":"Inverse of inverse","text":"<pre><code>#def inverse-twice\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-sym A y x (path-sym A x y p) = p\n  := path-ind A\n     ( \\ x' y' p' \u2192 path-sym A y' x' (path-sym A x' y' p') = p')\n     ( \\ _ \u2192 refl)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#associativity-of-concatenation","title":"Associativity of concatenation","text":"<pre><code>#def concat-assoc\n( A : U)\n( x y z w : A)\n( p : x = y)\n( q : y = z)\n( r : z = w)\n  : path-concat A x y w p (path-concat A y z w q r)\n    = path-concat A x z w (path-concat A x y z p q) r\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w')\n        \u2192 path-concat A x' y' w' p' (path-concat A y' z' w' q' r')\n          = path-concat A x' z' w' (path-concat A x' y' z' p' q') r')\n-- ? : (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w') \u2192\n-- path-concat A x' x' w' refl (path-concat A x' z' w' q' r') =\n-- path-concat A x' z' w' (path-concat A x' x' z' refl q') r' ) ===\n-- (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w') \u2192\n-- path-concat A x' z' w' q' r' = path-concat A x' z' w' q' r' )\n        ( \\ x' z' q' w' r' \u2192 refl)\n        x y p) z q w r\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/","title":"2.2 Functions are functors","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#action-on-paths","title":"Action on paths","text":"<p>Lemma 2.2.1 Action on path</p> <p>Suppose that \\(f : A \u2192 B\\) is a function. Then for any \\(x, y : A\\) there is an operation  \\(\\mathsf{ap}_f : (x =_A y) \\to (f(x) =_B f(y))\\). Moreover, for each \\(x : A\\) we have \\(\\mathsf{ap}_f (\\mathsf{refl}_x) \u2261 \\mathsf{refl}_{h(x)}\\).</p> <pre><code>#def ap\n( A B : U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n  : f x = f y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 f x' = f y')\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#properties","title":"Properties","text":"<p>Lemma 2.2.2. Functor laws</p> <p>For functions \\(f : A \u2192 B\\) and \\(g : B \u2192 C\\) and paths \\(p : x =_A y\\) and \\(q : y =_A z\\), we have:</p> <ol> <li>\\(\\mathsf{ap}_f(p \\cdot q) = \\mathsf{ap}_f(p)\\cdot \\mathsf{ap}_f(q)\\)</li> <li>\\(\\mathsf{ap}_f (p^{\u22121}) = \\mathsf{ap}_f (p)^{\u22121}\\)</li> <li>\\(\\mathsf{ap}_g(\\mathsf{ap}_f(p)) = \\mathsf{ap}_{g \\circ f} (p)\\)</li> <li>\\(\\mathsf{ap}_{id_A}(p)=p\\)</li> </ol>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#ap-disctributes-over-path-concatenation","title":"<code>ap</code> disctributes over path concatenation","text":"<pre><code>#def ap-concat\n( A B : U)\n( f : A \u2192 B)\n( x y z : A)\n( p : x = y)\n( q : y = z)\n  : ap A B f x z (path-concat A x y z p q)\n      = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q)\n  := (path-ind\n            A\n            ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 ap A B f x' z' (path-concat A x' y' z' p' q')\n                  = path-concat B (f x') (f y') (f z') (ap A B f x' y' p') (ap A B f y' z' q'))\n-- ? : (z' : A) \u2192 (q' : x' = z') \u2192 ap A B f x' z' (path-concat A x' x' z' refl q') =\n--      path-concat B (f x') (f x') (f z') (ap A B f x' x' refl) (ap A B f x' z' q')) ===\n-- (z' : A) \u2192 (q' : x' = z') \u2192 ap A B f x' z' q' = (ap A B f x' z' q'))\n            ( \\ x' z' q' \u2192 refl)\n            x y p) z q\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#action-of-path-and-path-inversion-commute","title":"Action of path and path inversion commute","text":"<pre><code>#def ap-inverse\n( A B : U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n  : ap A B f y x (path-sym A x y p)\n  = path-sym B (f x) (f y) (ap A B f x y p)\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap A B f y' x' (path-sym A x' y' p') = path-sym B (f x') (f y') (ap A B f x' y' p'))\n-- ? : ap A B f x' x' (path-sym A x' x' refl) = path-sym B (f x') (f y') (ap A B f x' x' refl) ===\n-- ap A B f x' x' refl = path-sym B (f x') (f y') refl ==\n-- refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#sequential-application-of-functions-to-paths-is-application-of-functions-composed","title":"Sequential application of functions to paths is application of functions composed","text":"<pre><code>#def ap-twice\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( x y : A)\n( p : x = y)\n  : ap B C g (f x) (f y) (ap A B f x y p)\n  = ap A C (\\ a \u2192 g (f a)) x y p\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap B C g (f x') (f y') (ap A B f x' y' p') = ap A C (\\ a \u2192 g(f a)) x' y' p')\n-- ?: ap B C g (f x') (f x') (ap A B f x' x' refl) = ap A C (\\ a \u2192 g(f a)) x' x' refl ===\n-- ap B C g (f x') (f x') refl = refl\n-- refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#identity-leaves-the-path-unchanged","title":"Identity leaves the path unchanged","text":"<pre><code>#def ap-id\n( A : U)\n( x y : A)\n( p : x = y)\n  : ap A A (\\ a \u2192 a) x y p = p\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap A A (\\ a \u2192 a) x' y' p' = p')\n-- ? : ap A A (\\ a \u2192 a) x' x' refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/","title":"2.3 Type families are fibrations","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#transport-path-lifting-and-dependent-map","title":"Transport, path lifting, and dependent map","text":"<p>Lemma 2.3.1. Transport</p> <p>Suppose that \\(P\\) is a type family over \\(A\\) and that \\(p : x =_A y\\). Then there is a function \\(p_\\ast : P(x) \u2192 P(y)\\).</p> <pre><code>#def transport\n( A : U)\n( P : A \u2192 U)\n( x y : A)\n( p : x = y)\n  : P x \u2192 P y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 P x' \u2192 P y')\n-- ? : P x' \u2192 P x'\n        ( \\ x' \u2192 \\ px \u2192 px)\n        x y p\n</code></pre> <p>Lemma 2.3.2. Path lifting property</p> <p>Let \\(P : A \\to U\\) be a type family over \\(A\\) and assume we have \\(u : P(x)\\) for some \\(x : A\\). Then for any \\(p : x = y\\), we have \\(\\mathsf{lift}(u, p) : (x, u) = (y, p_\\ast(u))\\) in \\(\\Sigma_{(x:A)} P(x)\\), such that \\(\\mathsf{pr}_1(\\mathsf{lift}(u, p)) = p\\) .</p> <pre><code>#def lift\n( A : U)\n( P : A \u2192 U)\n( x : A)\n( u : P x)\n( y : A)\n( p : x = y)\n  : ( x , u) =_{\u03a3 (z : A) , P z} (y , (transport A P x y p u))\n  := path-ind\n        A\n( \\ x' y' p' \u2192 (u' : P x') \u2192 (x' , u') =_{\u03a3 (z : A) , P z} (y' , (transport A P x' y' p' u')))\n-- ? : (u' : P x') \u2192 (x', u') = (x', (transport A P x' x' refl u')))\n-- (u' : P x') \u2192 (x', u') = (x', ((\\px \u2192 px) u'))\n-- u' \u2192 (x, u) = (x, u)\n        ( \\ x' u' \u2192 refl)\n        x y p u\n</code></pre> <p>Lemma 2.3.4. Dependent map</p> <p>Suppose \\(f : \\Pi_{(x:A)} P(x)\\); then we have a map \\(\\mathsf{apd}_f : \\Pi_{p:x=y} (p_\\ast(f(x)) =_{P(y)} f(y))\\).</p> <pre><code>#def apd\n( A : U)\n( P : A \u2192 U)\n( f : (z : A) \u2192 P z)\n( x y : A)\n( p : x = y)\n  : transport A P x y p (f x) = f y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 transport A P x' y' p' (f x') = f y')\n-- ? : transport A P x x refl (f x) = f x\n-- path-ind A C (\\ x' \u2192 \\ px \u2192 px) x x refl) (f x) = (f x)\n-- (\\ px \u2192 px) (f x) = (f x)\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#dependent-and-non-dependent-maps","title":"Dependent and non-dependent maps","text":"<p>Lemma 2.3.5. Transport in a constant type family</p> <p>If \\(P : A \\to U\\) is defined by \\(P(x) :\\equiv B\\) for a fixed \\(B : U\\), then for any \\(x,y : A\\) and \\(p : x = y\\) and \\(b : B\\) we have a path \\(\\mathsf{transportconst}^B_p (b) : \\mathsf{transport}^P(p, b) = b\\).</p> <pre><code>#def transportconst\n( A B : U)\n( b : B)\n( x y : A)\n( p : x = y)\n  : transport A (\\ _ \u2192 B) x y p b = b\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 transport A (\\ _ \u2192 B) x' y' p' b = b)\n-- ? : transport A (\\ _ \u2192 B) x' x' refl b = b\n-- (\\ px \u2192 px) b = b\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre> <p>Functions 2.3.6 and 2.3.7</p> <p>Inverse equivalences that relate \\(\\mathsf{ap}_f(p)\\) and \\(\\mathsf{apd}_f(p)\\):</p> <ul> <li>\\((f(x) = f(y)) \\to (p_\\ast(f(x)) = f(y))\\), and</li> <li>\\((p_\\ast(f(x)) = f(y)) \\to (f(x) = f(y))\\)</li> </ul> <pre><code>given\ntransportconst A B (f x) x y p  : transport A (\\ _ \u2192 B) x y p (f x) = f x\nand a hypothesis                : f x = f y\n\nfind                            : transport A (\\ _ \u2192 B) x y p (f x) = f y\n</code></pre> <pre><code>#def ap2apd\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : ( f x = f y) \u2192 (transport A (\\ _ \u2192 B) x y p (f x) = f y)\n  := \\ fp \u2192 path-concat B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (f y)\n        ( transportconst A B (f x) x y p)\n        fp\n</code></pre> <pre><code>given\ntransportconst A B (f x) x y p  : transport A (\\ _ \u2192 B) x y p (f x) = f x\nand a hypothesis                : transport A (\\ _ \u2192 B) x y p (f x) = f y\n\nfind                            : f x = f y\n</code></pre> <pre><code>#def apd2ap\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : ( transport A (\\ _ \u2192 B) x y p (f x) = f y) \u2192 (f x = f y)\n  := \\ fpd \u2192 path-concat B (f x) (transport A (\\ _ \u2192 B) x y p (f x)) (f y)\n        ( path-sym B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (transportconst A B (f x) x y p))\n        fpd\n</code></pre> <p>Lemma 2.3.8. \\(\\mathsf{ap}\\) and \\(\\mathsf{apd}\\) in a constant type family</p> <p>For \\(f : A \\to B\\) and \\(p : x =_A y\\), we have \\(\\mathsf{apd}_f(p) = \\mathsf{transportconst}_p^B(f(x)) \\cdot \\mathsf{ap}_f(p)\\)</p> <pre><code>#def apd-ap\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : apd A (\\ _ \u2192 B) f x y p = path-concat B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (f y)\n        ( transportconst A B (f x) x y p) (ap A B f x y p)\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 apd A (\\ _ \u2192 B) f x' y' p' = path-concat B (transport A (\\ _ \u2192 B) x' y' p' (f x')) (f x') (f y')\n            ( transportconst A B (f x') x' y' p') (ap A B f x' y' p'))\n-- ? : apd A (\\ _ \u2192 B) f x' x' refl = path-concat B (transport A (\\ _ \u2192 B) x' x' refl (f x')) (f x') (f x')\n--    (transportconst A B (f x') x' x' refl) (ap A B f x' x' refl) ===\n-- refl = path-concat B (f x') (f x') (f x') refl refl\n        ( \\ _ \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#properties-of-transport","title":"Properties of transport","text":"<p>Lemma 2.3.9. Transport along a concatenation of paths</p> <p>Given \\(P : A \\to U\\) with \\(p : x =_A y\\) and \\(q : y =_A z\\) while \\(u:P(x)\\), we have \\(q_\\ast(p_\\ast(u)) = (p \\cdot q)_\\ast(u)\\).</p> <pre><code>#def transport-concat\n( A : U)\n( P : A \u2192 U)\n( x y z : A)\n( p : x = y)\n( q : y = z)\n( u : P x)\n  : transport A P y z q (transport A P x y p u) = transport A P x z (path-concat A x y z p q) u\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P y' z' q' (transport A P x' y' p' u') = transport A P x' z' (path-concat A x' y' z' p' q') u')\n-- ? : (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P x' z' q' (transport A P x' x' refl u) = transport A P x' z' (path-concat A x' x' z' refl q') u\n-- \\ (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P x' z' q' u = transport A P x' z' q' u\n        ( \\ x' z' q' u' \u2192 refl)\n        x y p) z q u\n</code></pre> <p>Lemma 2.3.10. Transport along a path obtained by \\(\\mathsf{ap}_f\\)</p> <p>For a function \\(f : A \\to B\\) and a type family \\(P : B \\to U\\), and any \\(p : x =_A y\\) and \\(u : P(f(x))\\), we have \\(\\mathsf{transport} ^{P \\circ f}(p,u) = \\mathsf{transport}^P(\\mathsf{ap}_f(p),u)\\).</p> <pre><code>#def transport-ap\n( A B : U)\n( P : B \u2192 U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n( u : P (f x))\n  : transport A (\\ z \u2192 P (f z)) x y p u = transport B P (f x) (f y) (ap A B f x y p) u\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (u' : P (f x')) \u2192 transport A (\\ z \u2192 P (f z)) x' y' p' u' = transport B P (f x') (f y') (ap A B f x' y' p') u')\n-- ? :  (u : P x') \u2192 transport A (\\ z \u2192 P (f z)) x' x' refl = transport B P (f x') (f x') (ap A B f x' x' refl)\n-- (u : P x') \u2192 id u = transport B P (f x') (f x') refl u\n-- (u : P x') \u2192 id u = id u\n        ( \\ x' u' \u2192 refl)\n        x y p) u\n</code></pre> <p>Lemma 2.3.11. Function from fiber to fiber and transport in different type families can be rearranged</p> <p>For \\(P, Q : A \\to U\\) and a family of functions \\(f : \\Pi_{(x:A)} P(x) \\to Q(x)\\), and any \\(p : x =_A y\\) and \\(u : P(x)\\), we have \\(\\mathsf{transport}^Q(p, f_x(u)) = f_y(\\mathsf{transport}^P(p, u))\\).</p> <pre><code>#def transport-f\n( A : U)\n( P Q : A \u2192 U)\n( f : (x : A) \u2192 (P x) \u2192 (Q x))\n( x y : A)\n( p : x = y)\n( u : P x)\n  : transport A Q x y p (f x u) = f y (transport A P x y p u)\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (u' : P x') \u2192 transport A Q x' y' p' (f x' u') = f y' (transport A P x' y' p' u'))\n-- ? :  (u : P x') \u2192 transport A Q x' x' refl (f x' u') = f x' (transport A P x' x' refl u'))\n-- (u : P x') \u2192 id (f x' u') = f x' (id u'))\n-- (u : P x') \u2192 (f x' u') = (f x' u')\n        ( \\ x' u' \u2192 refl)\n        x y p) u\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-are-equivalences.rzk/","title":"2.4 Homotopies are equivalences","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/05-the-higher-groupoid-structure-of-type-formers.rzk/","title":"2.5 The higher groupoid structure of type formers","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/06-cartesian-product-types.rzk/","title":"2.6 Cartesian product types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/07-sigma-types.rzk/","title":"2.7 \\(\\Sigma\\)-types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/08-the-unit-type.rzk/","title":"2.8 The unit type","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/09-pi-types-and-function-extensionality.rzk/","title":"2.9 \\(\\Pi\\)-types and the function extensionality axiom","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/10-universes-and-univalence-axiom.rzk/","title":"2.10 Universes and univalence axiom","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/11-identity-type.rzk/","title":"2.11 Identity type","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/12-coproducts.rzk/","title":"2.12 Coproducts","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/13-natural-numbers.rzk/","title":"2.13 Natural numbers","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/14-example-equality-of-structures.rzk/","title":"2.14 Example: equality of structures","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/15-universal-properties.rzk/","title":"2.15 Universal properties","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/","title":"Exercises for Section 2","text":""},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-21","title":"Exercise 2.1","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-22","title":"Exercise 2.2","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-23","title":"Exercise 2.3","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-24","title":"Exercise 2.4","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-25","title":"Exercise 2.5","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-26","title":"Exercise 2.6","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-27","title":"Exercise 2.7","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-28","title":"Exercise 2.8","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-29","title":"Exercise 2.9","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-210","title":"Exercise 2.10","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-211","title":"Exercise 2.11","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-212","title":"Exercise 2.12","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-213","title":"Exercise 2.13","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-214","title":"Exercise 2.14","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-215","title":"Exercise 2.15","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-216","title":"Exercise 2.16","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-217","title":"Exercise 2.17","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-218","title":"Exercise 2.18","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/","title":"Solution to exercise 2.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Show that the three obvious proofs of Lemma 2.1.2 are pairwise equal.</p> <p>Lemma 2.1.2: (note we use \\(\\circ\\) instead of square dot due to technical limitations)</p> <p>For every type \\(A\\) and every \\(x, y, z : A\\) there is a function</p> \\[ (x = y) \\rightarrow (y = z) \\rightarrow (x = z), \\] <p>written \\(p \\mapsto q \\mapsto p \\circ q\\), such that \\(\\text{refl}_x \\circ \\text{refl}_x \\equiv \\text{refl}_x\\) for any \\(x : A\\). We call \\(p \\circ q\\) the concatenation or composite of \\(p\\) and \\(q\\).</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/#solution","title":"Solution","text":""},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/","title":"Solution to exercise 2.10","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/","title":"Solution to exercise 2.11","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/","title":"Solution to exercise 2.12","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/","title":"Solution to exercise 2.13","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/","title":"Solution to exercise 2.14","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/","title":"Solution to exercise 2.15","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/","title":"Solution to exercise 2.16","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/","title":"Solution to exercise 2.17","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/","title":"Solution to exercise 2.18","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/","title":"Solution to exercise 2.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/","title":"Solution to exercise 2.3","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/","title":"Solution to exercise 2.4","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/","title":"Solution to exercise 2.5","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/","title":"Solution to exercise 2.6","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/","title":"Solution to exercise 2.7","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/","title":"Solution to exercise 2.8","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/","title":"Solution to exercise 2.9","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"}]}