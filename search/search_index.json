{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HoTT Book formalisations in Rzk","text":"<p>This project contains formalisations that follow the HoTT Book.</p>"},{"location":"#how-to-check","title":"How to check","text":"<p>From the root of the project's repository, run:</p> <pre><code>rzk typecheck\n</code></pre>"},{"location":"1-foundations/0-chapter-template/01-section.rzk/","title":"0.1 Section name","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>References to the sections within the chapter should also be added to <code>mkdocs.yml</code></p>"},{"location":"1-foundations/0-chapter-template/02-section.rzk/","title":"0.2 Section name","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/","title":"Solution to exercise 0.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.1-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/","title":"Solution to exercise 0.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/0-chapter-template/exercises/0.2-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/04-dependent-function-types.rzk/","title":"1.4 Dependent function types (\\(\\Pi\\)-types)","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function:</p> <pre><code>#define id\n( A : U)\n  : A \u2192 A\n  := \\ x \u2192 x\n</code></pre> <p>Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function:</p> <pre><code>#define swap\n( A B C : U)\n  : ( A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\n  := \\ f y x \u2192 f x y\n</code></pre>"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/","title":"1.5 Product types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Rzk has built-in support for dependent pairs, so we define product types here in terms of those.</p> <pre><code>#define prod (A B : U)\n  : U\n  := \u03a3 (_ : A) , B\n</code></pre> <p>To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\)-types: <code>(a, b)</code>.</p> <p>To use a pair, we can use pattern matching or introduce projections:</p> <pre><code>#define pr\u2081\n( A B : U)\n  : prod A B \u2192 A\n  := \\ (a , _b) \u2192 a\n#define pr\u2082\n( A B : U)\n  : prod A B \u2192 B\n  := \\ (_a , b) \u2192 b\n</code></pre> <p>The recursor for product types can be defined as follows:</p> <pre><code>#define prod-rec\n( A B : U)\n  : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C\n  := \\ C f (a , b) \u2192 f a b\n</code></pre> <p>Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define</p> <pre><code>#define pr\u2081-via-rec\n( A B : U)\n  : prod A B \u2192 A\n  := prod-rec A B A (\\ a _b \u2192 a)\n#define pr\u2082-via-rec\n( A B : U)\n  : prod A B \u2192 B\n  := prod-rec A B B (\\ _a b \u2192 b)\n</code></pre> <p>To be able to define dependent functions over the product type, we have to generalize the recursor:</p> <pre><code>#define prod-ind\n( A B : U)\n  : ( C : prod A B \u2192 U) \u2192 ((x : A) \u2192 (y : B) \u2192 C (x , y)) \u2192 (x : prod A B) \u2192 C x\n  := \\ C f (x , y) \u2192 f x y\n</code></pre> <p>For example, in this way we can prove the propositional uniqueness principle, which says that every element of <code>A \u00d7 B</code> is equal to a pair. Specifically, we can construct a function</p> <pre><code>#define prod-uniq\n( A B : U)\n  : ( x : prod A B) \u2192 (pr\u2081 A B x , pr\u2082 A B x) =_{prod A B} x\n  := \\ (a , b) \u2192 refl_{(a , b)}\n</code></pre>"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/#unit-type","title":"Unit type","text":"<p>Rzk has a built-in <code>Unit</code> type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book.</p> <p>Still, following the book, here is the recursor for the unit type:</p> <pre><code>#define Unit-rec\n  : ( C : U) \u2192 C \u2192 Unit \u2192 C\n  := \\ _C c _unit \u2192 c\n</code></pre> <p>And, similarly, the induction principle for the unit type:</p> <pre><code>#define Unit-ind\n  : ( C : Unit \u2192 U) \u2192 C unit \u2192 (x : Unit) \u2192 C x\n  := \\ _C c unit \u2192 c\n</code></pre> <p>Induction enables us to prove the propositional uniqueness principle for <code>Unit</code>, which asserts that its only inhabitant is <code>unit</code>:</p> <pre><code>#define Unit-uniq\n  : ( x : Unit) \u2192 x = unit\n  := Unit-ind (\\ x \u2192 x = unit) refl_{unit}\n</code></pre> <p>As mentioned above, this uniqueness principle is built into Rzk (making any value of type <code>Unit</code> definitionally equal to <code>unit</code>), allowing to use <code>refl</code> immediately:</p> <pre><code>#define Unit-uniq'\n  : ( x : Unit) \u2192 x = unit\n  := \\ _ \u2192 refl\n</code></pre>"},{"location":"1-foundations/1-type-theory/06-dependent-pair-types.rzk/","title":"1.6 Dependent pair types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>TODO</p> <p>Add proper descriptions and check for missing definitions</p> <p><pre><code>#def pr\u2081-\u03a3\n( A : U)\n( B : A \u2192 U)\n  : ( \u03a3 ( x : A) , B x) \u2192 A\n  := \\ p \u2192 first p\n#def pr\u2082-\u03a3\n( A : U)\n( B : A \u2192 U)\n  : ( p : \u03a3 (x : A) , B x) \u2192 (B (first p))\n  := \\ p \u2192 second p\n</code></pre> Recursor for \\(\\Sigma\\)-types. They are called like this:</p> \\[ \\mathsf{rec}_{\\Sigma_{x : A}B(x)} ((C: U), (g: (x : A) \\rightarrow B (x) \\rightarrow C), (p: \\Sigma_{x : A} B(x))) \\] <pre><code>#def rec-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : U)\n  : ( g : (x : A) \u2192 B x \u2192 C) \u2192 (p : \u03a3 (x : A) , B x) \u2192 C\n  := \\ g (a , b) \u2192 g a b\n</code></pre> <pre><code>#def ind-\u03a3\n( A : U)\n( B : A \u2192 U)\n( C : (\u03a3 (x : A) , B x) \u2192 U)\n  : ( g : (x : A) \u2192 (y : B x) \u2192 C (x , y)) \u2192 (p : \u03a3 (x : A) , B x) \u2192 C p\n  := \\ g (a , b) \u2192 g a b\n</code></pre>"},{"location":"1-foundations/1-type-theory/07-coproduct-types.rzk/","title":"1.7 Coproduct types","text":"<p>Warning</p> <p>Coproduct types are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/08-booleans.rzk/","title":"1.8 The type of booleans","text":"<p>Warning</p> <p>Booleans are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/09-natural-numbers.rzk/","title":"1.9 The natural numbers","text":"<p>Warning</p> <p>Natural numbers (and user-defined data types) are currently not supported in rzk.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/10-pattern-matching-and-recursion.rzk/","title":"1.10 Pattern matching and recursion","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/11-propositions-as-types.rzk/","title":"1.11 Propositions as types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/12-identity-types.rzk/","title":"1.11 Identity types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Induction on identity type is defined with built-in <code>idJ</code> operator:</p> <pre><code>#def path-ind\n( A : U)\n( C : (x : A) \u2192 (y : A) \u2192 (x = y) \u2192 U)\n( d : (x : A) \u2192 C x x refl)\n  : ( x : A) \u2192 (y : A) \u2192 (p : x = y) \u2192 C x y p\n  := \\ x y p \u2192 idJ(A , x , C x , d x , y , p)\n</code></pre> <p>Indiscernability of identicals:</p> <pre><code>#def indiscernability-of-identicals\n( A : U)\n( C : A \u2192 U)\n  : ( x : A) \u2192 (y : A) \u2192 (p : x = y) \u2192 (C x) \u2192 (C y)\n  := path-ind\n    A\n    ( \\ x y p \u2192 ((C x) \u2192 (C y)))\n    ( \\ x \u2192 \\ cx \u2192 cx)\n</code></pre> <p>Based path induction directly corresponds to the <code>idJ</code> operator:</p> <pre><code>#def based-path-ind\n( A : U)\n( a : A)   \n( C : (x : A) \u2192 (a = x) \u2192 U)\n( ca : C a refl)\n  : ( x : A) \u2192 (p : a = x) \u2192 (C x p)\n  := \\ x p \u2192 idJ(A , a , C , ca , x , p)\n</code></pre> <p>Based path induction can be defined with the (usual) path induction:</p> <pre><code>#def based-path-ind'\n( A : U)\n  : ( a : A)\n  \u2192 ( C : (x : A) \u2192 (a = x) \u2192 U)\n  \u2192 ( ca : C a refl)\n  \u2192 ( x : A)\n  \u2192 ( p : a = x)\n  \u2192 ( C x p)\n  := \\ a C ca x p \u2192 \n  path-ind \n    A\n( \\ a' x' p' \u2192 (C' : ((x'' : A) \u2192 (a' = x'') \u2192 U)) \u2192 (C' a' refl) \u2192 (C' x' p'))\n    ( \\ a' \u2192 \\ C' ca' \u2192 ca')\n    a x p C ca\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/","title":"Exercises for Section 1","text":""},{"location":"1-foundations/1-type-theory/exercises/#exercise-11","title":"Exercise 1.1","text":"<p>Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\), define their composite \\(g \\circ f : A \\to C\\). Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\).</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-12","title":"Exercise 1.2","text":"<p>Derive the recursion principle for products \\(rec_{A \\times B}\\) using only the projections, and verify that the definitional equalities are valid. Do the same for \\(\\Sigma\\)-types.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-13","title":"Exercise 1.3","text":"<p>Derive the induction principle for products \\(ind_{A \\times B}\\), using only the projections and the propositional uniqueness principle \\(uniq_{A \\times B}\\). Verify that the definitional equalities are valid. Generalize \\(uniq_{A \\times B}\\) to \\(\\Sigma\\)-types, and do the same for \\(\\Sigma\\)-types. (This requires concepts from Chapter 2.)</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-14","title":"Exercise 1.4","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-15","title":"Exercise 1.5","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-16","title":"Exercise 1.6","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-17","title":"Exercise 1.7","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-18","title":"Exercise 1.8","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-19","title":"Exercise 1.9","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-110","title":"Exercise 1.10","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-111","title":"Exercise 1.11","text":"<p>Show that for any type \\(A\\), we have \\(\\lnot \\lnot \\lnot A \\to \\lnot A\\).</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-112","title":"Exercise 1.12","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-113","title":"Exercise 1.13","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-114","title":"Exercise 1.14","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-115","title":"Exercise 1.15","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/#exercise-116","title":"Exercise 1.16","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/","title":"Solution to exercise 1.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.1</p> <p>Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\), define their composite \\(g \\circ f : A \\to C\\). Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\).</p>"},{"location":"1-foundations/1-type-theory/exercises/1.1-solution.rzk/#solution","title":"Solution","text":"<p>First, the definition of the composition operation is provided as:</p> \\[ g \\circ f :\\equiv \\lambda (x: A) . g(f(x)) \\] <p>Then, associativity can be demonstrated by evaluating both sides of the equality and reaching the same result:</p> \\[     \\begin{align*}         h \\circ (g \\circ f) &amp; \\equiv \\lambda x. h((g\\circ f)(x)) \\\\                             &amp; \\equiv \\lambda x. h((\\lambda x' . g(f(x'))) (x)) \\\\                             &amp; \\equiv \\lambda x. h(g(f(x)))     \\end{align*} \\] \\[     \\begin{align*}         (h \\circ g) \\circ f &amp; \\equiv \\lambda x. (h\\circ g)(f(x)) \\\\                             &amp; \\equiv \\lambda x. (\\lambda y . h(g(y)))(f(x)) \\\\                             &amp; \\equiv \\lambda x. h(g(f(x)))     \\end{align*} \\] <p>This can be represented in rzk like so:</p> <pre><code>#define compose\n( A B C : U)\n( g : B \u2192 C)\n( f : A \u2192 B)\n  : A \u2192 C\n  := \\ x \u2192 g (f x)\n</code></pre> <p>Associativity is automatic (by <code>refl</code>):</p> <pre><code>#define composition-associativity\n( A B C D : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( h : C \u2192 D)\n  : compose A C D h (compose A B C g f) = compose A B D (compose B C D h g) f\n  := refl\n</code></pre> <p>An explicit proof (not checked by <code>rzk</code>):</p> <pre><code>compose A C D h (compose A B C g f)\n= \\ x \u2192 h ((compose A B C g f) x)       (unfolding compose)\n= \\ x \u2192 h ((\\ x2 \u2192 g (f x2)) x)         (unfolding compose)\n= \\ x \u2192 h (g (f x))                     (beta reduction)\n= \\ x \u2192 (\\ x2 \u2192 h (g x2)) (f x)         (beta reduction)\n= \\ x \u2192 (compose B C D h g) (f x)       (fold compose)\n= compose A B D (compose B C D h g) f   (fold compose)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/","title":"Solution to exercise 1.10","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.10-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/","title":"Solution to exercise 1.11","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.11</p> <p>Show that for any type \\(A\\), we have \\(\u00ac\u00ac\u00acA \u2192 \u00acA\\).</p>"},{"location":"1-foundations/1-type-theory/exercises/1.11-solution.rzk/#solution","title":"Solution","text":"<p>This is a weakened version of the double negation law and it holds constructively.</p> <p>Proposition \\(\\lnot X\\) corresponds to <code>(X \u2192 \u22a5)</code> type. We are given <code>f : (((A \u2192 \u22a5) \u2192 \u22a5) \u2192 \u22a5)</code> and <code>a : A</code> and we need to construct an element of type <code>\u22a5</code>. For that, we need to apply <code>f</code> to a term of type <code>((A \u2192 \u22a5) \u2192 \u22a5)</code>.  The term <code>\\ g \u2192 g a</code> has the required type.</p> <pre><code>#def triple-neg\n( A : U)\n  : ( ( ( A \u2192 \u22a5) \u2192 \u22a5) \u2192 \u22a5) \u2192 (A \u2192 \u22a5)\n  := \\ f a \u2192 f (\\ g \u2192 g a)\n</code></pre> <p>As the solution does not involve specifics of <code>\u22a5</code> type (in particular, that anything follows from it),  it is possible to generalise the solution to an arbitrary type <code>B</code> instead of <code>\u22a5</code>.</p> <pre><code>#def triple-neg'\n( A B : U)\n  : ( ( ( A \u2192 B) \u2192 B) \u2192 B) \u2192 (A \u2192 B)\n  := \\ f a \u2192 f (\\ g \u2192 g a)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/","title":"Solution to exercise 1.12","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.12-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/","title":"Solution to exercise 1.13","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.13-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/","title":"Solution to exercise 1.14","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.14-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/","title":"Solution to exercise 1.15","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.15-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/","title":"Solution to exercise 1.16","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.16-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/","title":"Solution to exercise 1.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Exercise 1.2</p> <p>Derive the recursion principle for products \\(\\mathsf{rec}_{A \\times B}\\) using only the projections, and verify that the definitional equalities are valid. Do the same for \\(\\Sigma\\)-types.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#solution-for-products","title":"Solution for products","text":"<p>In this solution, we use <code>prod</code> and projections (<code>pr\u2081</code> and <code>pr\u2082</code>), defined earlier in section 1.5.</p> <p>Introducing constructor for values of <code>prod</code> type:</p> <pre><code>#def pair\n( A B : U)\n  : A \u2192 B \u2192 prod A B\n  := \\ a b \u2192 (a , b)\n</code></pre> <p>The type of the recursor on \\(A \\times B\\) is</p> \\[ \\mathsf{rec}_{A \\times B}: \\prod_{C:\\mathcal{U}} (A \\to B \\to C) \\to A \\times B \\to C \\] <p>It can be defined using projection as such:</p> \\[ rec_{A\\times B}(C, g, x) :\\equiv g(\\mathsf{pr}_1(x))(\\mathsf{pr}_2(x)) \\] <p>And represented in rzk like so:</p> <pre><code>#def prod-rec-via-projections\n( A B : U)\n( C : U)\n( g : A \u2192 B \u2192 C)\n( p : prod A B)\n  : C\n  := g (pr\u2081 A B p) (pr\u2082 A B p)\n</code></pre> <p>Definitions of projections via recursion in the other direction (<code>pr\u2081-via-rec</code>, <code>pr\u2082-via-rec</code>) were already provided in section 1.5.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#checking-definitional-equalities","title":"Checking definitional equalities","text":"<p>Recursion from projections:</p> <pre><code>#def prod-rec-via-projections-works\n( A B C : U)\n( g : A \u2192 B \u2192 C)\n( a : A)\n( b : B)\n  : prod-rec-via-projections A B C g (pair A B a b) = g a b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p> <p>Projections from the recursion:</p> <pre><code>#def pr\u2081-via-rec-works\n( A B : U)\n( a : A)\n( b : B)\n  : pr\u2081-via-rec A B (pair A B a b) = a\n  := refl\n#def pr\u2082-from-rec-works\n( A B : U)\n( a : A)\n( b : B)\n  : pr\u2082-via-rec A B (pair A B a b) = b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#solution-for-dependant-pairs","title":"Solution for dependant pairs","text":"<p>Similarly, for \\(\\Sigma\\)-types, the recursion principle has the type:</p> \\[ \\mathsf{rec}_{\\Sigma_{x:A}B(x)} : \\Pi_{C:U}(\\Pi_{x:A} B(x) \\to C) \\to (\\Sigma_{x:A} B(x)) \\to C \\] <p>and can be defined using the projection functions as such:</p> \\[ \\mathsf{rec}_{\\Sigma_{x:A}B(x)}(C, g, x) :\\equiv g(\\mathsf{pr}_1(x))(\\mathsf{pr}_2(x)) \\] <p>\\(\\Sigma\\)-types are built-in. Also, <code>pr\u2081-\u03a3</code>, <code>pr\u2082-\u03a3</code>, <code>rec-\u03a3</code>, <code>ind-\u03a3</code> were already defined in section 1.6.</p> <p>Defining recursion from <code>pr\u2081-\u03a3</code> and <code>pr\u2082-\u03a3</code>:</p> <pre><code>#def rec-\u03a3-via-projections\n( A : U)\n( B : A \u2192 U)\n( C : U)\n( g : (x : A) \u2192 B x \u2192 C)\n( p : \u03a3 (x : A) , B x)\n  : C\n  := g (pr\u2081-\u03a3 A B p) (pr\u2082-\u03a3 A B p)\n</code></pre> <p>(Extra, not in the task) Other direction of definition (projecitons via recursion):</p> <pre><code>#def pr\u2081-\u03a3-via-rec\n( A : U)\n( B : A \u2192 U)\n  : ( \u03a3 ( x : A) , B x) \u2192 A\n  := rec-\u03a3 A B A (\\ x y \u2192 x)\n</code></pre> <p>For the second projection (\\(\\mathsf{pr}_2\\)) we need the induction, since the output type depends on \\(x : A\\):</p> <pre><code>#def pr\u2082-\u03a3-via-rec\n( A : U)\n( B : A \u2192 U)\n  : ( p : \u03a3 (x : A) , B x) \u2192 (B (pr\u2081-\u03a3-via-rec A B p))\n  := ind-\u03a3 A B (\\ p1 \u2192 B (pr\u2081-\u03a3-via-rec A B p1)) (\\ x y \u2192 y)\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.2-solution.rzk/#checking-the-definitional-equalities","title":"Checking the definitional equalities","text":"<pre><code>#def rec-\u03a3-via-projections-works\n( A : U)\n( B : A \u2192 U)\n( C : U)\n( g : (x : A) \u2192 B x \u2192 C)\n( a : A)\n( b : B a)\n  : rec-\u03a3-via-projections A B C g (a , b) = g a b\n  := refl\n#def pr\u2081-\u03a3-via-rec-works\n( A : U)\n( B : A \u2192 U)\n( a : A)\n( b : B a)\n  : pr\u2081-\u03a3-via-rec A B (a , b) = a\n  := refl\n#def pr\u2082-\u03a3-via-rec-works\n( A : U)\n( B : A \u2192 U)\n( a : A)\n( b : B a)\n  : pr\u2082-\u03a3-via-rec A B (a , b) = b\n  := refl\n</code></pre> <p>TODO</p> <p>Write down the explicit proofs (in latex/rzk syntax)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/","title":"Solution to exercise 1.3","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Derive the induction principle for products \\(ind_{A \\times B}\\), using only the projections and the propositional uniqueness principle \\(uniq_{A \\times B}\\). Verify that the definitional equalities are valid. Generalize \\(uniq_{A \\times B}\\) to \\(\\Sigma\\)-types, and do the same for \\(\\Sigma\\)-types. (This requires concepts from Chapter 2.)</p>"},{"location":"1-foundations/1-type-theory/exercises/1.3-solution.rzk/#solution","title":"Solution","text":""},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/","title":"Solution to exercise 1.4","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.4-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/","title":"Solution to exercise 1.5","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.5-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/","title":"Solution to exercise 1.6","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.6-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/","title":"Solution to exercise 1.7","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.7-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/","title":"Solution to exercise 1.8","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.8-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/","title":"Solution to exercise 1.9","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/1-type-theory/exercises/1.9-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/","title":"2.1 Types are higher groupoids","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Groupoids are categories in which all morphisms are isomorphisms. Alternativerly, groupoids can be viewed as a generalization of groups, where not all pairs of elements can be composed (but the group laws for the operation hold).</p>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#path-symmetry","title":"Path symmetry","text":"<p>Lemma 2.1.1. Symmetry / Inversion of paths / Inverse morphism</p> <p>For every type \\(A\\) and every \\(x, y : A\\) there is a function \\((x = y) \\to (y = x)\\) denoted \\(p \\mapsto p^{-1}\\), such that \\(\\mathsf{refl}_x^{-1} \\equiv \\mathsf{refl}_x\\) for each \\(x : A\\). We call \\(p^{-1}\\) the inverse of \\(p\\).</p> <pre><code>#def path-sym\n( A : U)\n( x y : A)\n  : ( x = y) \u2192 (y = x)\n  := path-ind\n    A\n    ( \\ x' y' _ \u2192 y' = x')\n    ( \\ z \u2192 refl)\n    x y\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#path-concatenation","title":"Path concatenation","text":"<p>Lemma 2.1.2. Transitivity / Path concatenation / Composition of morphisms</p> <p>For every type \\(A\\) and every \\(x, y, z : A\\) there is a function \\((x = y) \\to (y = z) \\to (x = z)\\), written \\(p \\mapsto q \\mapsto p \\cdot q\\), such that \\(\\mathsf{refl}_x \\cdot \\mathsf{refl}_x \\equiv \\mathsf{refl}_x\\) for any \\(x : A\\). We call \\(p \\cdot q\\) the concatenation or composite of \\(p\\) and \\(q\\).</p> <pre><code>#def path-concat\n( A : U)\n( x y z : A)\n  : ( x = y) \u2192 (y = z) \u2192 (x = z)\n  := \\ p \u2192 path-ind\n      A\n      ( \\ x' y' p' \u2192 ((y' = z) \u2192 (x' = z)))\n      ( \\ x' \u2192 \\ r \u2192 r)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#properties","title":"Properties","text":"<p>Lemma 2.1.4. Coherence laws</p> <p>Suppose \\(A : U\\), that \\(x, y, z, w : A\\) and that \\(p : x = y\\) and \\(q : y = z\\) and \\(r : z = w\\). We have the following:</p> <ol> <li>\\(p = p \\cdot \\mathsf{refl}\\) and \\(p=\\mathsf{refl} \\cdot p\\).</li> <li>\\(p^{-1} \\cdot p = \\mathsf{refl}\\) and \\(p \\cdot p^{-1} = \\mathsf{refl}\\).</li> <li>\\((p^{-1})^{-1} = p\\).</li> <li>\\(p \\cdot (q \\cdot r) = (p \\cdot q) \\cdot r\\).</li> </ol>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#composition-with-refl","title":"Composition with <code>refl</code>","text":"<pre><code>#def concat-refl\n( A : U)\n( x y : A)\n( p : x = y)\n  : p = path-concat A x y y p refl\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 p' = path-concat A x' y' y' p' refl)\n-- ? : refl = path-concat A x x x refl refl ==\n    ( \\ _ \u2192 refl)\n    x y p\n#def refl-concat\n( A : U)\n( x y : A)\n( p : x = y)\n  : p = path-concat A x x y refl p\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 p' = path-concat A x' x' y' refl p')\n-- ? : p = path-concat A x x x refl refl\n    ( \\ _ \u2192 refl)\n    x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#composition-with-inverse","title":"Composition with inverse","text":"<pre><code>#def inverse-l\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-concat A y x y (path-sym A x y p) p = refl\n  := path-ind\n    A\n    ( \\ x' y' p' \u2192 path-concat A y' x' y' (path-sym A x' y' p') p' = refl)\n    ( \\ _ \u2192 refl)\n    x y p\n#def inverse-r\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-concat A x y x p (path-sym A x y p) = refl\n  := path-ind A\n     ( \\ x' y' p' \u2192 path-concat A x' y' x' p' (path-sym A x' y' p') = refl)\n     ( \\ _ \u2192 refl)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#inverse-of-inverse","title":"Inverse of inverse","text":"<pre><code>#def inverse-twice\n( A : U)\n( x y : A)\n( p : x = y)\n  : path-sym A y x (path-sym A x y p) = p\n  := path-ind A\n     ( \\ x' y' p' \u2192 path-sym A y' x' (path-sym A x' y' p') = p')\n     ( \\ _ \u2192 refl)\n      x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#associativity-of-concatenation","title":"Associativity of concatenation","text":"<pre><code>#def concat-assoc\n( A : U)\n( x y z w : A)\n( p : x = y)\n( q : y = z)\n( r : z = w)\n  : path-concat A x y w p (path-concat A y z w q r)\n    = path-concat A x z w (path-concat A x y z p q) r\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w')\n        \u2192 path-concat A x' y' w' p' (path-concat A y' z' w' q' r')\n          = path-concat A x' z' w' (path-concat A x' y' z' p' q') r')\n-- ? : (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w') \u2192\n-- path-concat A x' x' w' refl (path-concat A x' z' w' q' r') =\n-- path-concat A x' z' w' (path-concat A x' x' z' refl q') r' ) ===\n-- (z' : A) \u2192 (q' : y' = z') \u2192 (w' : A) \u2192 (r' : z' = w') \u2192\n-- path-concat A x' z' w' q' r' = path-concat A x' z' w' q' r' )\n        ( \\ x' z' q' w' r' \u2192 refl)\n        x y p) z q w r\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#related-statements-used-in-further-proofs","title":"Related statements used in further proofs:","text":"<p>Concatencation of three paths</p> <pre><code>#def 3-path-concat\n( A : U)\n( x y z w : A)\n  : ( x = y) \u2192 (y = z) \u2192 (z = w) \u2192 (x = w)\n  := \\ p q r \u2192 path-concat A x z w (path-concat A x y z p q) r\n</code></pre> <p>Associativity symmetrical to 2.1.4-4</p> \\[(p \\cdot q) \\cdot r = p \\cdot (q \\cdot r)\\] <pre><code>#def concat-assoc-2\n( A : U)\n( x y z w : A)\n( p : x = y)\n( q : y = z)\n( r : z = w)\n  : path-concat A x z w (path-concat A x y z p q) r\n    = path-concat A x y w p (path-concat A y z w q r)\n  := path-sym\n      ( x = w)\n      ( path-concat A x y w p (path-concat A y z w q r))\n      ( path-concat A x z w (path-concat A x y z p q) r)\n      ( concat-assoc A x y z w p q r)\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/","title":"2.2 Functions are functors","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#action-on-paths","title":"Action on paths","text":"<p>Lemma 2.2.1 Action on path</p> <p>Suppose that \\(f : A \u2192 B\\) is a function. Then for any \\(x, y : A\\) there is an operation  \\(\\mathsf{ap}_f : (x =_A y) \\to (f(x) =_B f(y))\\). Moreover, for each \\(x : A\\) we have \\(\\mathsf{ap}_f (\\mathsf{refl}_x) \u2261 \\mathsf{refl}_{h(x)}\\).</p> <pre><code>#def ap\n( A B : U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n  : f x = f y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 f x' = f y')\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#properties","title":"Properties","text":"<p>Lemma 2.2.2. Functor laws</p> <p>For functions \\(f : A \u2192 B\\) and \\(g : B \u2192 C\\) and paths \\(p : x =_A y\\) and \\(q : y =_A z\\), we have:</p> <ol> <li>\\(\\mathsf{ap}_f(p \\cdot q) = \\mathsf{ap}_f(p)\\cdot \\mathsf{ap}_f(q)\\)</li> <li>\\(\\mathsf{ap}_f (p^{\u22121}) = \\mathsf{ap}_f (p)^{\u22121}\\)</li> <li>\\(\\mathsf{ap}_g(\\mathsf{ap}_f(p)) = \\mathsf{ap}_{g \\circ f} (p)\\)</li> <li>\\(\\mathsf{ap}_{id_A}(p)=p\\)</li> </ol>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#ap-disctributes-over-path-concatenation","title":"<code>ap</code> disctributes over path concatenation","text":"<pre><code>#def ap-concat\n( A B : U)\n( f : A \u2192 B)\n( x y z : A)\n( p : x = y)\n( q : y = z)\n  : ap A B f x z (path-concat A x y z p q)\n      = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q)\n  := (path-ind\n            A\n            ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 ap A B f x' z' (path-concat A x' y' z' p' q')\n                  = path-concat B (f x') (f y') (f z') (ap A B f x' y' p') (ap A B f y' z' q'))\n-- ? : (z' : A) \u2192 (q' : x' = z') \u2192 ap A B f x' z' (path-concat A x' x' z' refl q') =\n--      path-concat B (f x') (f x') (f z') (ap A B f x' x' refl) (ap A B f x' z' q')) ===\n-- (z' : A) \u2192 (q' : x' = z') \u2192 ap A B f x' z' q' = (ap A B f x' z' q'))\n            ( \\ x' z' q' \u2192 refl)\n            x y p) z q\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#action-of-path-and-path-inversion-commute","title":"Action of path and path inversion commute","text":"<pre><code>#def ap-inverse\n( A B : U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n  : ap A B f y x (path-sym A x y p)\n  = path-sym B (f x) (f y) (ap A B f x y p)\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap A B f y' x' (path-sym A x' y' p') = path-sym B (f x') (f y') (ap A B f x' y' p'))\n-- ? : ap A B f x' x' (path-sym A x' x' refl) = path-sym B (f x') (f y') (ap A B f x' x' refl) ===\n-- ap A B f x' x' refl = path-sym B (f x') (f y') refl ==\n-- refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#sequential-application-of-functions-to-paths-is-application-of-functions-composed","title":"Sequential application of functions to paths is application of functions composed","text":"<pre><code>#def ap-twice\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n( x y : A)\n( p : x = y)\n  : ap B C g (f x) (f y) (ap A B f x y p)\n  = ap A C (\\ a \u2192 g (f a)) x y p\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap B C g (f x') (f y') (ap A B f x' y' p') = ap A C (\\ a \u2192 g(f a)) x' y' p')\n-- ?: ap B C g (f x') (f x') (ap A B f x' x' refl) = ap A C (\\ a \u2192 g(f a)) x' x' refl ===\n-- ap B C g (f x') (f x') refl = refl\n-- refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#identity-leaves-the-path-unchanged","title":"Identity leaves the path unchanged","text":"<pre><code>#def ap-id\n( A : U)\n( x y : A)\n( p : x = y)\n  : ap A A (\\ a \u2192 a) x y p = p\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 ap A A (\\ a \u2192 a) x' y' p' = p')\n-- ? : ap A A (\\ a \u2192 a) x' x' refl = refl\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/","title":"2.3 Type families are fibrations","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#transport-path-lifting-and-dependent-map","title":"Transport, path lifting, and dependent map","text":"<p>Lemma 2.3.1. Transport</p> <p>Suppose that \\(P\\) is a type family over \\(A\\) and that \\(p : x =_A y\\). Then there is a function \\(p_\\ast : P(x) \u2192 P(y)\\).</p> <pre><code>#def transport\n( A : U)\n( P : A \u2192 U)\n( x y : A)\n( p : x = y)\n  : P x \u2192 P y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 P x' \u2192 P y')\n-- ? : P x' \u2192 P x'\n        ( \\ x' \u2192 \\ px \u2192 px)\n        x y p\n</code></pre> <p>Lemma 2.3.2. Path lifting property</p> <p>Let \\(P : A \\to U\\) be a type family over \\(A\\) and assume we have \\(u : P(x)\\) for some \\(x : A\\). Then for any \\(p : x = y\\), we have \\(\\mathsf{lift}(u, p) : (x, u) = (y, p_\\ast(u))\\) in \\(\\Sigma_{(x:A)} P(x)\\), such that \\(\\mathsf{pr}_1(\\mathsf{lift}(u, p)) = p\\) .</p> <pre><code>#def lift\n( A : U)\n( P : A \u2192 U)\n( x : A)\n( u : P x)\n( y : A)\n( p : x = y)\n  : ( x , u) =_{\u03a3 (z : A) , P z} (y , (transport A P x y p u))\n  := path-ind\n        A\n( \\ x' y' p' \u2192 (u' : P x') \u2192 (x' , u') =_{\u03a3 (z : A) , P z} (y' , (transport A P x' y' p' u')))\n-- ? : (u' : P x') \u2192 (x', u') = (x', (transport A P x' x' refl u')))\n-- (u' : P x') \u2192 (x', u') = (x', ((\\px \u2192 px) u'))\n-- u' \u2192 (x, u) = (x, u)\n        ( \\ x' u' \u2192 refl)\n        x y p u\n</code></pre> <p>Lemma 2.3.4. Dependent map</p> <p>Suppose \\(f : \\Pi_{(x:A)} P(x)\\); then we have a map \\(\\mathsf{apd}_f : \\Pi_{p:x=y} (p_\\ast(f(x)) =_{P(y)} f(y))\\).</p> <pre><code>#def apd\n( A : U)\n( P : A \u2192 U)\n( f : (z : A) \u2192 P z)\n( x y : A)\n( p : x = y)\n  : transport A P x y p (f x) = f y\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 transport A P x' y' p' (f x') = f y')\n-- ? : transport A P x x refl (f x) = f x\n-- path-ind A C (\\ x' \u2192 \\ px \u2192 px) x x refl) (f x) = (f x)\n-- (\\ px \u2192 px) (f x) = (f x)\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#dependent-and-non-dependent-maps","title":"Dependent and non-dependent maps","text":"<p>Lemma 2.3.5. Transport in a constant type family</p> <p>If \\(P : A \\to U\\) is defined by \\(P(x) :\\equiv B\\) for a fixed \\(B : U\\), then for any \\(x,y : A\\) and \\(p : x = y\\) and \\(b : B\\) we have a path \\(\\mathsf{transportconst}^B_p (b) : \\mathsf{transport}^P(p, b) = b\\).</p> <pre><code>#def transportconst\n( A B : U)\n( b : B)\n( x y : A)\n( p : x = y)\n  : transport A (\\ _ \u2192 B) x y p b = b\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 transport A (\\ _ \u2192 B) x' y' p' b = b)\n-- ? : transport A (\\ _ \u2192 B) x' x' refl b = b\n-- (\\ px \u2192 px) b = b\n        ( \\ x' \u2192 refl)\n        x y p\n</code></pre> <p>Functions 2.3.6 and 2.3.7</p> <p>Inverse equivalences that relate \\(\\mathsf{ap}_f(p)\\) and \\(\\mathsf{apd}_f(p)\\):</p> <ul> <li>\\((f(x) = f(y)) \\to (p_\\ast(f(x)) = f(y))\\), and</li> <li>\\((p_\\ast(f(x)) = f(y)) \\to (f(x) = f(y))\\)</li> </ul> <pre><code>given\ntransportconst A B (f x) x y p  : transport A (\\ _ \u2192 B) x y p (f x) = f x\nand a hypothesis                : f x = f y\n\nfind                            : transport A (\\ _ \u2192 B) x y p (f x) = f y\n</code></pre> <pre><code>#def ap2apd\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : ( f x = f y) \u2192 (transport A (\\ _ \u2192 B) x y p (f x) = f y)\n  := \\ fp \u2192 path-concat B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (f y)\n        ( transportconst A B (f x) x y p)\n        fp\n</code></pre> <pre><code>given\ntransportconst A B (f x) x y p  : transport A (\\ _ \u2192 B) x y p (f x) = f x\nand a hypothesis                : transport A (\\ _ \u2192 B) x y p (f x) = f y\n\nfind                            : f x = f y\n</code></pre> <pre><code>#def apd2ap\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : ( transport A (\\ _ \u2192 B) x y p (f x) = f y) \u2192 (f x = f y)\n  := \\ fpd \u2192 path-concat B (f x) (transport A (\\ _ \u2192 B) x y p (f x)) (f y)\n        ( path-sym B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (transportconst A B (f x) x y p))\n        fpd\n</code></pre> <p>Lemma 2.3.8. \\(\\mathsf{ap}\\) and \\(\\mathsf{apd}\\) in a constant type family</p> <p>For \\(f : A \\to B\\) and \\(p : x =_A y\\), we have \\(\\mathsf{apd}_f(p) = \\mathsf{transportconst}_p^B(f(x)) \\cdot \\mathsf{ap}_f(p)\\)</p> <pre><code>#def apd-ap\n( A B : U)\n( x y : A)\n( p : x = y)\n( f : A \u2192 B)\n  : apd A (\\ _ \u2192 B) f x y p = path-concat B (transport A (\\ _ \u2192 B) x y p (f x)) (f x) (f y)\n        ( transportconst A B (f x) x y p) (ap A B f x y p)\n  := path-ind\n        A\n        ( \\ x' y' p' \u2192 apd A (\\ _ \u2192 B) f x' y' p' = path-concat B (transport A (\\ _ \u2192 B) x' y' p' (f x')) (f x') (f y')\n            ( transportconst A B (f x') x' y' p') (ap A B f x' y' p'))\n-- ? : apd A (\\ _ \u2192 B) f x' x' refl = path-concat B (transport A (\\ _ \u2192 B) x' x' refl (f x')) (f x') (f x')\n--    (transportconst A B (f x') x' x' refl) (ap A B f x' x' refl) ===\n-- refl = path-concat B (f x') (f x') (f x') refl refl\n        ( \\ _ \u2192 refl)\n        x y p\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#properties-of-transport","title":"Properties of transport","text":"<p>Lemma 2.3.9. Transport along a concatenation of paths</p> <p>Given \\(P : A \\to U\\) with \\(p : x =_A y\\) and \\(q : y =_A z\\) while \\(u:P(x)\\), we have \\(q_\\ast(p_\\ast(u)) = (p \\cdot q)_\\ast(u)\\).</p> <pre><code>#def transport-concat\n( A : U)\n( P : A \u2192 U)\n( x y z : A)\n( p : x = y)\n( q : y = z)\n( u : P x)\n  : transport A P y z q (transport A P x y p u) = transport A P x z (path-concat A x y z p q) u\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P y' z' q' (transport A P x' y' p' u') = transport A P x' z' (path-concat A x' y' z' p' q') u')\n-- ? : (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P x' z' q' (transport A P x' x' refl u) = transport A P x' z' (path-concat A x' x' z' refl q') u\n-- \\ (z' : A) \u2192 (q' : y' = z') \u2192 (u' : P x') \u2192 transport A P x' z' q' u = transport A P x' z' q' u\n        ( \\ x' z' q' u' \u2192 refl)\n        x y p) z q u\n</code></pre> <p>Lemma 2.3.10. Transport along a path obtained by \\(\\mathsf{ap}_f\\)</p> <p>For a function \\(f : A \\to B\\) and a type family \\(P : B \\to U\\), and any \\(p : x =_A y\\) and \\(u : P(f(x))\\), we have \\(\\mathsf{transport} ^{P \\circ f}(p,u) = \\mathsf{transport}^P(\\mathsf{ap}_f(p),u)\\).</p> <pre><code>#def transport-ap\n( A B : U)\n( P : B \u2192 U)\n( f : A \u2192 B)\n( x y : A)\n( p : x = y)\n( u : P (f x))\n  : transport A (\\ z \u2192 P (f z)) x y p u = transport B P (f x) (f y) (ap A B f x y p) u\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (u' : P (f x')) \u2192 transport A (\\ z \u2192 P (f z)) x' y' p' u' = transport B P (f x') (f y') (ap A B f x' y' p') u')\n-- ? :  (u : P x') \u2192 transport A (\\ z \u2192 P (f z)) x' x' refl = transport B P (f x') (f x') (ap A B f x' x' refl)\n-- (u : P x') \u2192 id u = transport B P (f x') (f x') refl u\n-- (u : P x') \u2192 id u = id u\n        ( \\ x' u' \u2192 refl)\n        x y p) u\n</code></pre> <p>Lemma 2.3.11. Function from fiber to fiber and transport in different type families can be rearranged</p> <p>For \\(P, Q : A \\to U\\) and a family of functions \\(f : \\Pi_{(x:A)} P(x) \\to Q(x)\\), and any \\(p : x =_A y\\) and \\(u : P(x)\\), we have \\(\\mathsf{transport}^Q(p, f_x(u)) = f_y(\\mathsf{transport}^P(p, u))\\).</p> <pre><code>#def transport-f\n( A : U)\n( P Q : A \u2192 U)\n( f : (x : A) \u2192 (P x) \u2192 (Q x))\n( x y : A)\n( p : x = y)\n( u : P x)\n  : transport A Q x y p (f x u) = f y (transport A P x y p u)\n  := (path-ind\n        A\n        ( \\ x' y' p' \u2192 (u' : P x') \u2192 transport A Q x' y' p' (f x' u') = f y' (transport A P x' y' p' u'))\n-- ? :  (u : P x') \u2192 transport A Q x' x' refl (f x' u') = f x' (transport A P x' x' refl u'))\n-- (u : P x') \u2192 id (f x' u') = f x' (id u'))\n-- (u : P x') \u2192 (f x' u') = (f x' u')\n        ( \\ x' u' \u2192 refl)\n        x y p) u\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/","title":"2.4 Homotopies and equivalences","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#homotopies-between-functions","title":"Homotopies between functions","text":"<p>Definition 2.4.1.</p> <p>Let \\(f, g : \\prod_{(x:A)} P(x)\\) be two sections of a type family \\(P : A \\to U\\). A homotopy from \\(f\\) to \\(g\\) is a dependent function of type</p> \\[(f \\sim g) :\\equiv \\prod_{(x:A)} (f(x) = g(x)).\\] <pre><code>#def homotopy\n( A : U)\n( P : A \u2192 U)\n( f g : (x : A) \u2192 P x)\n  : U\n  := (x : A) \u2192 f x = g x\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#homotopies-are-equivalence-relations","title":"Homotopies are equivalence relations","text":"<p>Lemma 2.4.2.</p> <p>Homotopy is an equivalence relation on each dependent function type \\(\\prod_{(x:A)} P(x)\\). That is, we have elements of the types</p> \\[\\prod_{f : \\prod_{(x:A)} P(x)} (f \\sim f)\\] \\[\\prod_{f, g : \\prod_{(x:A)} P(x)} (f \\sim g) \\to (g \\sim f)\\] \\[\\prod_{f, g, h : \\prod_{(x:A)} P(x)} (f \\sim g) \\to (g \\sim h) \\to (f \\sim h)\\]"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#reflexivity","title":"Reflexivity","text":"<pre><code>#def homotopy-refl\n( A : U)\n( P : A \u2192 U)\n( f : (x : A) \u2192 P x)\n  : homotopy A P f f\n  := \\ x \u2192 refl\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#symmetry","title":"Symmetry","text":"<pre><code>#def homotopy-sym\n( A : U)\n( P : A \u2192 U)\n( f g : (x : A) \u2192 P x)\n  : homotopy A P f g \u2192 homotopy A P g f\n  :=\n\\ hom x \u2192\n    path-sym (P x) (f x) (g x) (hom x)\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#transitivity","title":"Transitivity","text":"<pre><code>#def homotopy-trans\n( A : U)\n( P : A \u2192 U)\n( f g h : (x : A) \u2192 P x)\n  : homotopy A P f g\n  \u2192 homotopy A P g h\n  \u2192 homotopy A P f h\n  :=\n\\ hom-fg hom-gh x \u2192\n    path-concat (P x) (f x) (g x) (h x) (hom-fg x) (hom-gh x)\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#naturality","title":"Naturality","text":"<p>Lemma 2.4.3.</p> <p>Suppose \\(H : f \\sim g\\) is a homotopy between functions \\(f, g: A \\to B\\) and let \\(p : x =_A y\\). Then we have</p> \\[H(x) \\cdot g(p) = f(p) \\cdot H(y).\\] <p>Tip</p> <p>When dealing with paths, authors write \\(f(p)\\) to mean \\(ap_f(p)\\).</p> <pre><code>#def hom-naturality\n( A B : U)\n( f g : A \u2192 B)\n( H : homotopy A (\\ _ \u2192 B) f g)\n  : ( x : A)\n  \u2192 ( y : A)\n  \u2192 ( p : x = y)\n  \u2192 path-concat B (f x) (g x) (g y) (H x) (ap A B g x y p)\n  = path-concat B (f x) (f y) (g y) (ap A B f x y p) (H y)\n  :=\n  path-ind A\n  ( \\ x' y' p' \u2192\n      path-concat B (f x') (g x') (g y') (H x') (ap A B g x' y' p')\n    = path-concat B (f x') (f y') (g y') (ap A B f x' y' p') (H y'))\n  ( \\ x' \u2192 path-sym -- H x' \u2219 refl = H x'\n            ( f x' = g x')\n            ( H x')\n            ( path-concat B (f x') (g x') (g x') (H x') refl)\n            ( concat-refl B (f x') (g x') (H x')) -- H x' = H x' \u2219 refl\n        )\n</code></pre> <p>Corollary 2.4.4.</p> <p>Let \\(H : f \\sim id_A\\) be a homotopy, with \\(f : A \\to A\\). Then, for any \\(x : A\\) we have</p> \\[H(f(x)) = f(H(x)).\\] <p>Here \\(f(x)\\) denotes the ordinary application of \\(f\\) to \\(x\\), while \\(f(H(x))\\) denotes \\(ap_f(H(x))\\).</p> <p>Proof <code>homotopy-id-swap</code> is given in the end of the file.</p>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#quasi-inverses","title":"Quasi-Inverses","text":"<p>The traditional notion of isomorphism is poorly behaved for proof-relevant mathematics. Thus, it is given the name of quasi-inverse.</p> <p>Definition 2.4.6.</p> <p>For a function \\(f : A \u2192 B\\), a quasi-inverse of \\(f\\) is a triple \\((g, \\alpha, \\beta)\\) consisting of a function \\(g : B \u2192 A\\) and homotopies \\(\\alpha : f \\circ g \\sim id_B\\) and \\(\\beta : g \\circ f \\sim id_A\\).</p> <pre><code>#def qinv\n( A B : U)\n( f : A \u2192 B)\n  : U\n  :=\n\u03a3 ( g : B \u2192 A)\n  , prod\n    ( homotopy B (\\ _ \u2192 B) (compose B A B f g) (id B))\n    ( homotopy A (\\ _ \u2192 A) (compose A B A g f) (id A))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#examples","title":"Examples","text":"<p>Example 2.4.7. Identity quasi-inverse</p> <p>The identity function \\(id_A : A \\to A\\) has a quasi-inverse given by \\(id_A\\) itself, together with homotopies defined by \\(\\alpha(y) :\\equiv \\mathsf{refl}_y\\) and \\(\\beta(x) :\\equiv \\mathsf{refl}_x\\).</p> <pre><code>#def qinv-id\n( A : U)\n  : qinv A A (id A)\n  :=\n  ( id A\n  , ( \\ y \u2192 refl_{y}\n    , \\ x \u2192 refl_{x}))\n</code></pre> <p>Example 2.4.8. Quasi-inverse for path concatenation</p> <p>For any \\(p : x =_A y\\) and \\(z : A\\), the functions \\((p \\cdot \u2013) : (y =_A z) \\to (x =_A z)\\) and \\((\u2013 \\cdot p) : (z =_A x) \\to (z =_A y)\\) have quasi-inverses given by \\((p^{\u22121} \\cdot \u2013)\\) and \\((\u2013 \\cdot p^{\u22121})\\), respectively.</p>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#quasi-inverse-has-a-quasi-inverse","title":"Quasi-inverse has a quasi-inverse","text":"<pre><code>#define inverse-from-qinv\n( A B : U)\n( f : A \u2192 B)\n  : qinv A B f \u2192 (B \u2192 A)\n  := \\ (g , _) \u2192 g\n#define qinv-inverse-from-qinv\n( A B : U)\n( f : A \u2192 B)\n  : ( qinv-f : qinv A B f)\n  \u2192 qinv B A (inverse-from-qinv A B f qinv-f)\n  := \\ (g , (\u03b1 , \u03b2)) \u2192 (f , (\u03b2 , \u03b1))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#quasi-inverse-of-the-concatenation-from-the-right-side","title":"Quasi-inverse of the concatenation from the right side","text":"<p>Change of variables in the code</p> <p>Note the change of variables: \\(p \\mapsto q, x \\mapsto y, y \\mapsto z, z \\mapsto x\\). That is, the code corrsesponds to the statement that for any \\(q : y =_A z\\) and \\(x : A\\), the function \\((\u2013 \\cdot q) : (x =_A y) \\to (x =_A z)\\) have quasi-inverse given by \\((\u2013 \\cdot q^{\u22121})\\), respectively.</p> Definition of right concatenation as a function, and its inverse<pre><code>#def right-concat\n( A : U)\n( x y z : A)\n( q : y = z)\n  : ( x = y) \u2192 (x = z)\n  := \\ p \u2192 path-concat A x y z p q\n#def right-concat-inv\n( A : U)\n( x y z : A)\n( q : y = z)\n  : ( x = z) \u2192 (x = y)\n  := right-concat A x z y (path-sym A y z q)\n</code></pre> Proofs that both compositions are homotopical to identity<pre><code>#def right-concat-right-inv-remove-refl\n( A : U)\n( x y z : A)\n( p : x = y)\n  : ( q : y = z)\n  \u2192 right-concat-inv A x y z q (right-concat A x y z q p) -- (p \u2219 q) \u2219 q\u207b\u00b9\n  = p\n  :=\n  path-ind A\n( \\ x' y' p' \u2192\n      ( q : y' = z) \u2192 right-concat-inv A x' y' z q (right-concat A x' y' z q p') = p')\n  ( \\ x' \u2192 inverse-r A x' z)\n  ( x)\n  ( y)\n  ( p)\n#def right-concat-left-inv-remove-refl\n( A : U)\n( x y z : A)\n( r : x = z)\n  : ( q : y = z)\n  \u2192 right-concat A x y z q (right-concat-inv A x y z q r) -- (r \u2219 q\u207b\u00b9) \u2219 q\n  = r\n  :=\n  path-ind A\n( \\ x' z' r' \u2192\n      ( q : y = z') \u2192 right-concat A x' y z' q (right-concat-inv A x' y z' q r') = r')\n  ( \\ x' \u2192 inverse-l A y x')\n  ( x)\n  ( z)\n  ( r)\n</code></pre> Proof for quasi-inverse of right concatenation<pre><code>#def right-concat-inv-is-qinv-for-right-concat\n( A : U)\n( x y z : A)\n( q : y = z)\n  : qinv (x = y) (x = z) (right-concat A x y z q)\n  :=\n( right-concat-inv A x y z q\n  , ( \\ (r : x = z) \u2192 right-concat-left-inv-remove-refl  A x y z r q\n    , \\ (p : x = y) \u2192 right-concat-right-inv-remove-refl A x y z p q))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#equivalences","title":"Equivalences","text":"<p>An improved notion, <code>isequiv</code>, has the following properties:</p> <ol> <li>For each \\(f : A \\to B\\) there is a function \\(\\mathsf{qinv}(f) \\to \\mathsf{isequiv}(f)\\)</li> <li>Similarly, for each \\(f\\) we have \\(\\mathsf{isequiv}(f) \\to \\mathsf{qinv}(f)\\); thus the two are logically equivalent.</li> <li>For any two inhabitants \\(e_1, e_2 : \\mathsf{isequiv}(f)\\), we have \\(e_1 = e_2\\).</li> </ol> <p>One of numerous, but equivalent ways to define <code>isequiv</code>:</p> <p>Definition 2.4.10.</p> \\[\\mathsf{isequiv}(f) :\\equiv \\left(\\sum_{(g:B \\to A)} (f \\circ g \\sim id_B)\\right) \\times \\left(\\sum_{(h:B \\to A)} (h \\circ f \\sim id_A)\\right).\\] <pre><code>#def isequiv\n( A B : U)\n( f : A \u2192 B)\n  : U\n  :=\n  prod\n( \u03a3 ( g : B \u2192 A) , homotopy B (\\ _ \u2192 B) (compose B A B f g) (id B))\n( \u03a3 ( h : B \u2192 A) , homotopy A (\\ _ \u2192 A) (compose A B A h f) (id A))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#proof-of-property-1","title":"Proof of Property 1","text":"<p>For the \\(\\mathsf{qinv}(f) \\to \\mathsf{isequiv}(f)\\) direction, \\(g\\) can play the role of both \\(g\\) and \\(h\\), i.e. we take \\((g, \\alpha, \\beta)\\) to \\((g, \\alpha, g, \\beta)\\).</p> <pre><code>#def qinv-to-isequiv\n( A B : U)\n( f : A \u2192 B)\n  : qinv A B f \u2192 isequiv A B f\n  := \\ (g , (\u03b1 , \u03b2)) \u2192 ((g , \u03b1) , (g , \u03b2))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#proof-of-property-2","title":"Proof of Property 2","text":"<p>For the other direction, we are given \\((g, \\alpha, h, \\beta)\\). Notice that \\(h \\circ f \\circ g \\sim_{\\alpha} h\\) and \\(h \\circ f \\circ g \\sim_{\\beta} g\\). Let \\(\\gamma\\) be the composite homotopy</p> <pre><code>$$g \\sim_{\\beta^{-1}} h \\circ f \\circ g \\sim_{\\alpha} h,$$\n\nmeaning $\\gamma(x) :\\equiv \\beta(g(x))^{-1} \\cdot h(\\alpha(x))$. Now define $\\beta'(x) :\\equiv \\gamma(f(x)) \\cdot \\beta(x)$. Then $(g, \\alpha, \\beta) : \\mathsf{qinv}(f)'$.\n</code></pre> <pre><code>#def isequiv-to-qinv\n( A B : U)\n( f : A \u2192 B)\n  : isequiv A B f \u2192 qinv A B f\n  :=\n  \\ ((g , \u03b1) , (h , \u03b2)) \u2192\n    ( g\n      , ( \u03b1\n        , \\ x \u2192\n-- g (f x) = h (f (g (f x))) = h (f x) = x\n            path-concat A -- g (f x) = id x\n            ( compose A B A g f x)\n            ( compose A B A h f x)\n            ( id A x)\n            ( path-concat A -- g (f x) = h (f x)\n              ( g (f x))\n              ( h (f (g (f x))))\n              ( h (f x))\n              ( path-sym A -- g (f x) = (h . f . g) (f x)\n                ( compose A B A h f (g (f x)))\n                ( id A (g (f x)))\n                ( \u03b2 (g (f x))))\n              ( ap B A h -- (h . f . g) (f x) = h (f x)\n                ( compose B A B f g (f x))\n                ( id B (f x))\n                ( \u03b1 (f x))))\n            ( \u03b2 x))) -- h (f x) = id x\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#proof-of-property-3","title":"Proof of Property 3","text":"<p>Proof of the third property requires identifying the identity types of cartesian products and dependent pair types, which are discussed in Sections 2.6 and 2.7.</p>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#equivalence-of-types","title":"Equivalence of types","text":"<p>Definition 2.4.11.</p> <p>An equivalence from type \\(A\\) to type \\(B\\) is defined to be a function \\(f : A \\to B\\) together with an inhabitant of \\(\\mathsf{isequiv}(f)\\).</p> \\[(A \\simeq B) :\\equiv \\sum_{(f:A \\to B)} \\mathsf{isequiv}(f).\\] <p>Note</p> <p>If we have a function \\(f : A \\to B\\) and we know that \\(e : \\mathsf{isequiv}(f)\\), we may write \\(f : A \\simeq B\\), rather than \\((f, e)\\).</p> <pre><code>#def equivalence\n( A B : U)\n  : U\n  := \u03a3 (f : A \u2192 B) , isequiv A B f\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#type-equivalences-are-equivalence-relations","title":"Type equivalences are equivalence relations","text":"<p>Lemma 2.4.12.</p> <p>Type equivalence is an equivalence relation on \\(U\\). More specifically:</p> <ol> <li>For any \\(A\\), the identity function \\(id_A\\) is an equivalence; hence \\(A \\simeq A\\).</li> <li>For any \\(f : A \\simeq B\\), we have an equivalence \\(f^{-1} : B \\simeq A\\).</li> <li>For any \\(f : A \\simeq B\\) and \\(g : B \\simeq C\\), we have \\(g \\circ f : A \\simeq C\\).</li> </ol>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#reflexivity_1","title":"Reflexivity","text":"<pre><code>#def equivalence-refl\n( A : U)\n  : equivalence A A\n  :=\n  ( id A\n  , ( ( id A , \\ x \u2192 refl)\n    , ( id A , \\ x \u2192 refl)))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#symmetry_1","title":"Symmetry","text":"<pre><code>#def inverse-from-isequiv\n( A B : U)\n( f : A \u2192 B)\n  : isequiv A B f \u2192 (B \u2192 A)\n  :=\n\\ isequiv-f \u2192\n    inverse-from-qinv A B f\n    ( isequiv-to-qinv A B f isequiv-f)\n#def inverse-from-equivalence\n( A B : U)\n  : equivalence A B \u2192 (B \u2192 A)\n  :=\n  \\ (f , isequiv-f) \u2192\n    inverse-from-isequiv A B f isequiv-f\n#def isequiv-inverse-from-equivalence\n( A B : U)\n  : ( f : equivalence A B)\n  \u2192 isequiv B A (inverse-from-equivalence A B f)\n  :=\n  \\ (f , isequiv-f) \u2192\n    qinv-to-isequiv B A\n    ( inverse-from-equivalence A B (f , isequiv-f))\n    ( qinv-inverse-from-qinv A B f (isequiv-to-qinv A B f isequiv-f))\n#def equivalence-sym\n( A B : U)\n  : equivalence A B \u2192 equivalence B A\n  :=\n\\ f \u2192\n    ( inverse-from-equivalence A B f\n    , isequiv-inverse-from-equivalence A B f)\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#transitivity_1","title":"Transitivity","text":"<pre><code>#define qinv-trans\n( A B C : U)\n( f : A \u2192 B)\n( g : B \u2192 C)\n  : qinv A B f \u2192 qinv B C g \u2192 qinv A C (compose A B C g f)\n  :=\n  \\ (f\u207b\u00b9 , (\u03b1-f , \u03b2-f)) (g\u207b\u00b9 , (\u03b1-g , \u03b2-g)) \u2192\n    ( compose C B A f\u207b\u00b9 g\u207b\u00b9\n    , ( \\ c \u2192\n          path-concat C\n          ( g (f (f\u207b\u00b9 (g\u207b\u00b9 c))))\n          ( g (g\u207b\u00b9 c))\n          ( c)\n          ( ap B C g\n            ( f (f\u207b\u00b9 (g\u207b\u00b9 c)))\n            ( g\u207b\u00b9 c)\n            ( \u03b1-f (g\u207b\u00b9 c)))\n          ( \u03b1-g c)\n      , \\ a \u2192\n          path-concat A\n          ( f\u207b\u00b9 (g\u207b\u00b9 (g (f a))))\n          ( f\u207b\u00b9 (f a))\n          ( a)\n          ( ap B A f\u207b\u00b9\n            ( g\u207b\u00b9 (g (f a)))\n            ( f a)\n            ( \u03b2-g (f a)))\n          ( \u03b2-f a)))\n#define equivalence-trans\n( A B C : U)\n  : equivalence A B\n  \u2192 equivalence B C\n  \u2192 equivalence A C\n  :=\n  \\ (f , isequiv-f) (g , isequiv-g) \u2192\n    ( compose A B C g f\n    , qinv-to-isequiv A C\n      ( compose A B C g f)\n      ( qinv-trans A B C f g\n        ( isequiv-to-qinv A B f isequiv-f)\n        ( isequiv-to-qinv B C g isequiv-g)))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-and-equivalences.rzk/#proof-of-corollary-244","title":"Proof of Corollary 2.4.4","text":"Proof for corollary 2.4.4. Homotopy with id<pre><code>lemma 2.4.3 :  H(x) \u2022 g  (p)   = f (p)   \u2022 H y\n\nSubstitutions:\nx \u2192 f x\ny \u2192 x\ng \u2192 id\np \u2192 H x\n\nResult of application of lemma with the corresponding values:\nH(f x) \u2022 id (H x) = f (H x) \u2022 H x\n\nBy right-concatenating (H x)\u207b\u00b9 to the both sides, we have\nH(f x) = H(f x) \u2022 id (H x) \u2022 (H x)\u207b\u00b9 = f (H x) \u2022 H x \u2022 (H x)\u207b\u00b9 = f (H x)\n</code></pre> <pre><code>#def homotopy-id-swap\n( A : U)\n( f : A \u2192 A)\n( H : homotopy A (\\ _ \u2192 A) f (id A))\n( x : A)\n  : H (f x) = ap A A f (f x) (id A x) (H x)\n  :=\n  3-path-concat\n  ( f (f x) = (f x)) -- type of points\n-- 1st point: H (f x)\n  ( H (f x))\n-- 2nd point: (H (f x) \u2022 (H x)) \u2022 (H x)\u207b\u00b9\n  ( path-concat A (f (f x)) x (f x)\n    ( path-concat A (f (f x)) (f x) x\n      ( H (f x))\n      ( H x))\n    ( path-sym A (f x) x\n      ( H x)))\n-- 3rd point:  (f (H x) \u2022 (H x)) \u2022 (H x)\u207b\u00b9\n  ( path-concat A (f (f x)) x (f x)\n    ( path-concat A (f (f x)) (f x) x\n      ( ap A A f (f x) x (H x))\n      ( H x))\n    ( path-sym A (f x) x\n      ( H x)))\n-- 4th point: f (H x)\n  ( ap A A f (f x) x (H x))\n-- proof that H (f x) = (H (f x) \u2022 H x) \u2022 (H x)\u207b\u00b9\n  ( path-sym\n    ( f (f x) = f x)\n    ( path-concat A (f (f x)) x (f x)\n      ( path-concat A (f (f x)) (f x) x\n        ( H (f x))\n        ( H x))\n      ( path-sym A (f x) x\n        ( H x)))\n    ( H (f x))\n    ( right-concat-right-inv-remove-refl A (f (f x)) (f x) x\n      ( H (f x))\n      ( H x)))\n-- proof that (H (f x) \u2022 H x) \u2022 (H x)\u207b\u00b9 = (f (H x) \u2022 (H x)) \u2022 (H x)\u207b\u00b9\n  ( ap\n    ( f (f x) = x) -- (type of domain)\n    ( f (f x) = f x) -- (type of codomain)\n    ( \\ p' \u2192\n        path-concat A (f (f x)) x (f x)\n          ( p')\n          ( path-sym A (f x) x\n            ( H x)))\n-- function-to-apply: whiskering by (Hx)\u207b\u00b9, a.k.a. cancel out H x\n    ( path-concat A (f (f x)) (f x) x\n      ( H (f x))\n      ( H x)) -- left point in path below\n    ( path-concat A (f (f x)) (f x) x\n      ( ap A A f (f x) x (H x))\n      ( H x)) -- right point in path below\n    ( path-concat\n        ( f (f x) = x)\n-- (H (f x) \u2022 H x)\n        ( path-concat A (f (f x)) (f x) x\n          ( H (f x))\n          ( H x))\n-- (H (f x) \u2022 id (H x))\n        ( path-concat A (f (f x)) (f x) x\n          ( H (f x))\n          ( ap A A (\\ z \u2192 z) (f x) x (H x)))\n-- f (H x) \u2022 (H x)\n        ( path-concat A (f (f x)) (f x) x\n          ( ap A A f (f x) x (H x))\n          ( H x))\n-- (H (f x) \u2022 H x) = (H (f x) \u2022 id (H x))\n        ( ap\n          ( f x = x) -- domain\n          ( ( f (f x)) = x) -- codomain\n          ( \\ p' \u2192\n              path-concat A (f (f x)) (f x) x\n                ( H (f x))\n                ( p')) -- action of concatenation\n          ( H x) -- left point in path\n          ( ap A A (\\ z \u2192 z) (f x) x (H x)) -- right point in path\n          ( path-sym (f x = x)\n            ( ap A A (\\ z \u2192 z) (f x) x (H x))\n            ( H x)\n            ( ap-id A (f x) x (H x))))\n-- (H (f x) \u2022 id (H x)) = f (H x) \u2022 (H x)\n        ( hom-naturality A A f (\\ z \u2192 z) H (f x) x (H x))))\n-- proof that (f (H x) \u2022 (H x)) \u2022 (H x)\u207b\u00b9 = f (H x)\n  ( right-concat-right-inv-remove-refl A (f (f x)) (f x) x\n    ( ap A A f (f x) (id A x) (H x))\n    ( H x))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/05-the-higher-groupoid-structure-of-type-formers.rzk/","title":"2.5 The higher groupoid structure of type formers","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/06-cartesian-product-types.rzk/","title":"2.6 Cartesian product types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>For any elements \\(x, y : A \\times B\\) and a path \\(p : x =_{A \\times B} y\\), by functoriality we can extract paths \\(\\mathsf{pr}_1(p) : \\mathsf{pr}_1(x) =_A \\mathsf{pr}_1(y)\\) and \\(\\mathsf{pr}_2(p) : \\mathsf{pr}_2(x) =_B \\mathsf{pr}_2(y)\\).</p> <pre><code>#def path-in-prod-to-prod-of-paths\n( A B : U)\n( x y : prod A B)\n  : ( x = y)\n  \u2192 prod\n    ( pr\u2081 A B x = pr\u2081 A B y)\n    ( pr\u2082 A B x = pr\u2082 A B y)\n  :=\n\\ p \u2192\n    ( ap (prod A B) A (pr\u2081 A B) x y p\n    , ap (prod A B) B (pr\u2082 A B) x y p)\n</code></pre> <p>Theorem 2.6.2. Paths in a product space are pairs of paths</p> <p>The function</p> \\[(x =_{A \\times B} y) \u2192 (\\mathsf{pr}_1(x) =_A \\mathsf{pr}_1(y)) \\times (\\mathsf{pr}_2(x) =_B \\mathsf{pr}_2(y)).\\] <p>is an equivalence</p> <pre><code>#def prod-of-paths-to-path-in-prod\n( A B : U)\n( a\u2081 a\u2082 : A)\n( b\u2081 b\u2082 : B)\n  : prod (a\u2081 = a\u2082) (b\u2081 = b\u2082)\n  \u2192 ( a\u2081 , b\u2081) = (a\u2082 , b\u2082)\n  :=\n  \\ (pa , pb) \u2192\n    path-ind A\n    ( \\ x y p \u2192 (x , b\u2081) = (y , b\u2082))\n    ( \\ x \u2192\n        path-ind B\n        ( \\ x' y' _p' \u2192 (x , x') = (x , y'))\n        ( \\ _x' \u2192 refl)\n        ( b\u2081)\n        ( b\u2082)\n        ( pb))\n    ( a\u2081)\n    ( a\u2082)\n    ( pa)\n</code></pre> <pre><code>#def prod-path-qinv\n( A B : U)\n( a\u2081 a\u2082 : A)\n( b\u2081 b\u2082 : B)\n  : qinv\n    ( ( a\u2081 , b\u2081) = (a\u2082 , b\u2082))\n    ( prod (a\u2081 = a\u2082) (b\u2081 = b\u2082))\n    ( path-in-prod-to-prod-of-paths A B (a\u2081 , b\u2081) (a\u2082 , b\u2082))\n  :=\n  ( prod-of-paths-to-path-in-prod A B a\u2081 a\u2082 b\u2081 b\u2082\n  , ( \\ (pa , pb) \u2192\n        path-ind A\n        ( \\ x y p \u2192\n          path-in-prod-to-prod-of-paths A B (x , b\u2081) (y , b\u2082)\n          ( prod-of-paths-to-path-in-prod A B x y b\u2081 b\u2082\n            ( p , pb))\n        = ( p , pb))\n        ( \\ x \u2192\n            path-ind B\n            ( \\ x' y' p' \u2192\n                path-in-prod-to-prod-of-paths A B (x , x') (x , y')\n                ( prod-of-paths-to-path-in-prod A B x x x' y'\n                  ( refl , p'))\n              = ( refl , p'))\n            ( \\ x' \u2192 refl)\n            ( b\u2081)\n            ( b\u2082)\n            ( pb)\n        )\n        ( a\u2081)\n        ( a\u2082)\n        ( pa)\n      , \\ pab \u2192\n          path-ind (prod A B)\n          ( \\ (a\u2081' , b\u2081') (a\u2082' , b\u2082') pab' \u2192\n              prod-of-paths-to-path-in-prod A B a\u2081' a\u2082' b\u2081' b\u2082'\n              ( path-in-prod-to-prod-of-paths A B (a\u2081' , b\u2081') (a\u2082' , b\u2082')\n                ( pab'))\n            = pab')\n          ( \\ x \u2192 refl)\n          ( a\u2081 , b\u2081)\n          ( a\u2082 , b\u2082)\n          ( pab)\n      )\n  )\n</code></pre> <pre><code>#def paths-in-prod-equiv-prod-of-paths\n( A B : U)\n( a\u2081 a\u2082 : A)\n( b\u2081 b\u2082 : B)\n  : equivalence\n    ( ( a\u2081 , b\u2081) = (a\u2082 , b\u2082))\n    ( prod (a\u2081 = a\u2082) (b\u2081 = b\u2082))\n  :=\n  ( path-in-prod-to-prod-of-paths A B (a\u2081 , b\u2081) (a\u2082 , b\u2082)\n  , qinv-to-isequiv\n    ( ( a\u2081 , b\u2081) = (a\u2082 , b\u2082))\n    ( prod (a\u2081 = a\u2082) (b\u2081 = b\u2082))\n    ( path-in-prod-to-prod-of-paths A B (a\u2081 , b\u2081) (a\u2082 , b\u2082))\n    ( prod-path-qinv A B a\u2081 a\u2082 b\u2081 b\u2082))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/07-sigma-types.rzk/","title":"2.7 \\(\\Sigma\\)-types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/08-the-unit-type.rzk/","title":"2.8 The unit type","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>For <code>Unit</code> type, uniqueness principle is built-in. That is, for any <code>x, y : Unit</code>, we have <code>refl : x = y</code></p> <p>Theorem 2.8.1.</p> <p>For any \\(x, y : \\mathbb{1}\\), we have \\((x = y) \\simeq \\mathbb{1}\\).</p> <pre><code>#def paths-in-unit-equiv-unit\n( x y : Unit)\n  : equivalence (x = y) Unit\n-- provide a function - a constant map to unit\n  :=\n( \\ (p : x = y) \u2192 unit\n  , ( -- provide right inverse - a constant map to refl_{unit}\n( \\ (u : Unit) \u2192 refl_{unit}\n      , -- prove that composition is homotopical to id_Unit\n        \\ (u : Unit) \u2192 refl)\n    , -- provide left inverse - a constant map to refl_{unit}\n( \\ (u : Unit) \u2192 refl_{unit}\n      , -- prove that composition is homotopical to id_{x = y}; use path induction on p\n        path-ind Unit\n        ( \\ x' y' p' \u2192 refl_{unit} = p')\n        ( \\ x' \u2192 refl)\n        x y)))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/09-pi-types-and-function-extensionality.rzk/","title":"2.9 \\(\\Pi\\)-types and the function extensionality axiom","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> HoTT Book, Definition 2.9.2<pre><code>#define happly\n( A : U)\n( B : A \u2192 U)\n( f g : (a : A) \u2192 B a)\n  : ( f = g) \u2192 homotopy A B f g\n  :=\n  path-ind ((a : A) \u2192 B a)\n  ( \\ f' g' _ \u2192 homotopy A B f' g')\n  ( \\ f' _ \u2192 refl)\n  f g\n</code></pre> HoTT Book, Axiom 2.9.3<pre><code>#define FunExt\n  : U\n  :=\n( A : U)\n  \u2192 ( B : A \u2192 U)\n  \u2192 ( f : (a : A) \u2192 B a)\n  \u2192 ( g : (a : A) \u2192 B a)\n  \u2192 isequiv\n    ( f = g)\n    ( homotopy A B f g)\n    ( happly A B f g)\n</code></pre> <pre><code>#assume funext : FunExt\n</code></pre> <pre><code>#define map-funext uses (funext)\n( A : U)\n( B : A \u2192 U)\n( f g : (a : A) \u2192 B a)\n  : homotopy A B f g \u2192 f = g\n  := first (second (funext A B f g))\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/10-universes-and-univalence-axiom.rzk/","title":"2.10 Universes and univalence axiom","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/11-identity-type.rzk/","title":"2.11 Identity type","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/12-coproducts.rzk/","title":"2.12 Coproducts","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/13-natural-numbers.rzk/","title":"2.13 Natural numbers","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/14-example-equality-of-structures.rzk/","title":"2.14 Example: equality of structures","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/15-universal-properties.rzk/","title":"2.15 Universal properties","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/","title":"Exercises for Section 2","text":""},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-21","title":"Exercise 2.1","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-22","title":"Exercise 2.2","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-23","title":"Exercise 2.3","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-24","title":"Exercise 2.4","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-25","title":"Exercise 2.5","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-26","title":"Exercise 2.6","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-27","title":"Exercise 2.7","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-28","title":"Exercise 2.8","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-29","title":"Exercise 2.9","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-210","title":"Exercise 2.10","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-211","title":"Exercise 2.11","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-212","title":"Exercise 2.12","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-213","title":"Exercise 2.13","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-214","title":"Exercise 2.14","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-215","title":"Exercise 2.15","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-216","title":"Exercise 2.16","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-217","title":"Exercise 2.17","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/#exercise-218","title":"Exercise 2.18","text":"<p>Warning</p> <p>Description is missing.</p> <p>Go to solution</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/","title":"Solution to exercise 2.1","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Show that the three obvious proofs of Lemma 2.1.2 are pairwise equal.</p> <p>Lemma 2.1.2: (note we use \\(\\circ\\) instead of square dot due to technical limitations)</p> <p>For every type \\(A\\) and every \\(x, y, z : A\\) there is a function</p> \\[ (x = y) \\rightarrow (y = z) \\rightarrow (x = z), \\] <p>written \\(p \\mapsto q \\mapsto p \\circ q\\), such that \\(\\text{refl}_x \\circ \\text{refl}_x \\equiv \\text{refl}_x\\) for any \\(x : A\\). We call \\(p \\circ q\\) the concatenation or composite of \\(p\\) and \\(q\\).</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.1-solution.rzk/#solution","title":"Solution","text":""},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/","title":"Solution to exercise 2.10","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.10-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/","title":"Solution to exercise 2.11","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.11-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/","title":"Solution to exercise 2.12","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.12-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/","title":"Solution to exercise 2.13","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.13-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/","title":"Solution to exercise 2.14","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.14-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/","title":"Solution to exercise 2.15","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.15-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/","title":"Solution to exercise 2.16","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.16-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/","title":"Solution to exercise 2.17","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.17-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/","title":"Solution to exercise 2.18","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.18-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/","title":"Solution to exercise 2.2","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.2-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/","title":"Solution to exercise 2.3","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.3-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/","title":"Solution to exercise 2.4","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.4-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/","title":"Solution to exercise 2.5","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.5-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/","title":"Solution to exercise 2.6","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.6-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/","title":"Solution to exercise 2.7","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.7-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/","title":"Solution to exercise 2.8","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.8-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/","title":"Solution to exercise 2.9","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#problem-statement","title":"Problem statement","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part-1","title":"Solution (part 1)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part-2","title":"Solution (part 2)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/2-homotopy-type-theory/exercises/2.9-solution.rzk/#solution-part","title":"Solution (part ...)","text":"<p>Warning</p> <p>To be done.</p>"},{"location":"1-foundations/3-sets-and-logic/01-sets-and-n-types.rzk/","title":"3.1 Sets and \\(n\\)-types","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>This module assumes function extensionality:</p> <pre><code>#assume funext : FunExt\n</code></pre> <p>In general, types behave like spaces or higher groupoids, but there is a subclass of types that behave more like sets in a traditional sense. We expect a type to be a set, if there is no higher homotopical information.</p> <p>Definition 3.1.1.</p> <p>A type \\(A\\) is a set if for all \\(x, y : A\\) and all \\(p, q : x = y\\), we have \\(p = q\\).</p> <pre><code>#def isSet\n( A : U)\n  : U\n  :=\n( x : A)\n  \u2192 ( y : A)\n  \u2192 ( p : x = y)\n  \u2192 ( q : x = y)\n  \u2192 ( p = q)\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/01-sets-and-n-types.rzk/#some-examples","title":"Some examples","text":"<p>Many of the proofs below appeal to the injectivity of equivalences:</p> <pre><code>#define injective-equivalence\n( A B : U)\n  ( ( f , isequiv-f) : equivalence A B)\n( x y : A)\n  : ( f x = f y)\n  \u2192 ( x = y)\n  :=\n\\ fx-eq-fy \u2192\n    3-path-concat A\n    ( x)\n    ( first (second isequiv-f) (f x))\n    ( first (second isequiv-f) (f y))\n    ( y)\n    ( path-sym A\n      ( first (second isequiv-f) (f x))\n      ( x)\n      ( second (second isequiv-f) x))\n    ( ap B A\n      ( first (second isequiv-f))\n      ( f x)\n      ( f y)\n      fx-eq-fy)\n    ( second (second isequiv-f) y)\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/01-sets-and-n-types.rzk/#unit-type-is-a-set","title":"Unit type is a set","text":"<p>Example 3.1.2.</p> <p>The type \\(\\mathbb{1}\\) is a set.</p> <pre><code>#def isSet-Unit\n  : isSet Unit\n  :=\n\\ x y p q \u2192\n    injective-equivalence\n    ( x = y)\n    ( Unit)\n    ( paths-in-unit-equiv-unit x y)\n    ( p)\n    ( q)\n    ( refl)\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/01-sets-and-n-types.rzk/#products-of-sets-are-sets","title":"Products of sets are sets","text":"<p>Example 3.1.5.</p> <p>If \\(A\\) and \\(B\\) are sets, then so is \\(A \\times B\\).</p> <pre><code>#def isSet-prod\n( A B : U)\n( isSet-A : isSet A)\n( isSet-B : isSet B)\n  : isSet (prod A B)\n  :=\n  \\ (a\u2081 , b\u2081) (a\u2082 , b\u2082) p q \u2192\n    injective-equivalence\n    ( ( a\u2081 , b\u2081) = (a\u2082 , b\u2082))\n    ( prod (a\u2081 = a\u2082) (b\u2081 = b\u2082))\n    ( paths-in-prod-equiv-prod-of-paths A B a\u2081 a\u2082 b\u2081 b\u2082)\n    ( p)\n    ( q)\n    ( prod-of-paths-to-path-in-prod\n      ( a\u2081 = a\u2082)\n      ( b\u2081 = b\u2082)\n      ( ap (prod A B) A (pr\u2081 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) p)\n      ( ap (prod A B) A (pr\u2081 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) q)\n      ( ap (prod A B) B (pr\u2082 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) p)\n      ( ap (prod A B) B (pr\u2082 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) q)\n      ( ( isSet-A a\u2081 a\u2082\n          ( ap (prod A B) A (pr\u2081 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) p)\n          ( ap (prod A B) A (pr\u2081 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) q)\n        , isSet-B b\u2081 b\u2082\n          ( ap (prod A B) B (pr\u2082 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) p)\n          ( ap (prod A B) B (pr\u2082 A B) (a\u2081 , b\u2081) (a\u2082 , b\u2082) q)))\n    )\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/01-sets-and-n-types.rzk/#function-types-into-sets-form-sets","title":"Function types into sets form sets","text":"<p>Example 3.1.6</p> <p>If \\(A\\) is any type and \\(B : A \\to \\mathcal{U}\\) is such that each \\(B(x)\\) is a set, then the type \\(\\prod_{(x:A)} B(x)\\) is a set.</p> <pre><code>#define weak-isSet-function\n( A B : U)\n( isSet-B : isSet B)\n( f g : A \u2192 B)\n( p q : homotopy A (\\ _ \u2192 B) f g)\n  : homotopy A (\\ x \u2192 f x = g x) p q\n  := \\ x \u2192 isSet-B (f x) (g x) (p x) (q x)\n#define weak-isSet-function\u2081\n( A B : U)\n( isSet-B : isSet B)\n( f g : A \u2192 B)\n( p q : f = g)\n  : homotopy A (\\ x \u2192 f x = g x)\n    ( happly A (\\ _ \u2192 B) f g p)\n    ( happly A (\\ _ \u2192 B) f g q)\n  :=\n  weak-isSet-function A B isSet-B f g\n  ( happly A (\\ _ \u2192 B) f g p)\n  ( happly A (\\ _ \u2192 B) f g q)\n#define weak-isSet-function\u2082 uses (funext)\n( A B : U)\n( isSet-B : isSet B)\n( f g : A \u2192 B)\n( p q : f = g)\n  : happly A (\\ _ \u2192 B) f g p\n  = happly A (\\ _ \u2192 B) f g q\n  :=\n  map-funext funext A (\\ x \u2192 f x = g x)\n  ( happly A (\\ _ \u2192 B) f g p)\n  ( happly A (\\ _ \u2192 B) f g q)\n  ( weak-isSet-function\u2081 A B isSet-B f g p q)\n#define isSet-function uses (funext)\n( A B : U)\n( isSet-B : isSet B)\n  : isSet (A \u2192 B)\n  :=\n\\ f g p q \u2192\n    injective-equivalence\n    ( f = g)\n    ( homotopy A (\\ _ \u2192 B) f g)\n    ( happly A (\\ _ \u2192 B) f g\n    , funext A (\\ _ \u2192 B) f g)\n    ( p)\n    ( q)\n    ( weak-isSet-function\u2082 A B isSet-B f g p q)\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/02-propositions-as-types.rzk/","title":"Propositions as types?","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/03-mere-propositions.rzk/","title":"Mere propositions","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>This module assumes function extensionality:</p> <pre><code>#assume funext : FunExt\n</code></pre> <p>Definition 3.3.1</p> <p>A type \\(P\\) is a mere proposition if for all \\(x, y : P\\) we have \\(x = y\\).</p> <pre><code>#define isProp\n( A : U)\n  : U\n  := (x : A) \u2192 (y : A) \u2192 x = y\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/03-mere-propositions.rzk/#examples","title":"Examples","text":"<pre><code>#define isProp-Unit\n  : isProp Unit\n  := \\ unit unit \u2192 refl\n</code></pre> <pre><code>#define isProp-function uses (funext)\n( A : U)\n( B : A \u2192 U)\n( isProp-B : (a : A) \u2192 isProp (B a))\n  : isProp ((a : A) \u2192 B a)\n  := \\ f g \u2192 map-funext funext A B f g (\\ a \u2192 isProp-B a (f a) (g a))\n</code></pre>"},{"location":"1-foundations/3-sets-and-logic/11-contractibility.rzk/","title":"Contractibility","text":"<p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>Definition 3.11.1</p> <p>A type \\(A\\) is contractible, or a singleton, if there is \\(a : A\\), called the center of contraction, such that \\(a = x\\) for all \\(x : A\\). We denote the specified path \\(a = x\\) by \\(\\mathsf{contr}_{x}\\).</p> <pre><code>#define isContr\n( A : U)\n  : U\n  := \u03a3 (a : A) , (x : A) \u2192 a = x\n#define center\n( A : U)\n  : isContr A \u2192 A\n  := \\ (a , _) \u2192 a\n#define contr\n( A : U)\n( isContr-A : isContr A)\n( x : A)\n  : center A isContr-A = x\n  := second isContr-A x\n</code></pre>"}]}