{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HoTT Book formalisations in Rzk \u00b6 This project contains formalisations that follow the HoTT Book . How to check \u00b6 From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"General"},{"location":"#hott-book-formalisations-in-rzk","text":"This project contains formalisations that follow the HoTT Book .","title":"HoTT Book formalisations in Rzk"},{"location":"#how-to-check","text":"From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"How to check"},{"location":"1-foundations/1-type-theory/04-dependent-function-types.rzk/","text":"1.4 Dependent function types ( \\(\\Pi\\) -types) \u00b6 This is a literate Rzk file: #lang rzk-1 A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function: #define id ( A : U) : A \u2192 A := \\ x \u2192 x Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function: #define swap ( A B C : U) : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C) := \\ f y x \u2192 f x y","title":"1.4 Dependent function types"},{"location":"1-foundations/1-type-theory/04-dependent-function-types.rzk/#14-dependent-function-types-pi-types","text":"This is a literate Rzk file: #lang rzk-1 A polymorphic function is one which takes a type as one of its arguments, and then acts on elements of that type (or of other types constructed from it). An example is the polymorphic identity function: #define id ( A : U) : A \u2192 A := \\ x \u2192 x Another, less trivial, example of a polymorphic function is the \"swap\" operation that switches the order of the arguments of a (curried) two-argument function: #define swap ( A B C : U) : (A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C) := \\ f y x \u2192 f x y","title":"1.4 Dependent function types (\\(\\Pi\\)-types)"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/","text":"1.5 Product types \u00b6 This is a literate Rzk file: #lang rzk-1 Rzk has built-in support for dependent pairs, so we define product types here in terms of those. #define prod ( A B : U) : U := \u03a3 ( _ : A), B To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\) -types: (a, b) . To use a pair, we can use pattern matching or introduce projections: #define pr\u2081 ( A B : U) : prod A B \u2192 A := \\ (a, _b) \u2192 a #define pr\u2082 ( A B : U) : prod A B \u2192 B := \\ (_a, b) \u2192 b The recursor for product types can be defined as follows: #define prod-rec ( A B : U) : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C := \\ C f (a, b) \u2192 f a b Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define #define pr\u2081' ( A B : U) : prod A B \u2192 A := prod-rec A B A ( \\ a _b \u2192 a) #define pr\u2082' ( A B : U) : prod A B \u2192 B := prod-rec A B B ( \\ _a b \u2192 b) To be able to define dependent functions over the product type, we have to generalize the recursor: #define prod-ind ( A B : U) : ( C : prod A B \u2192 U) \u2192 ( (x : A) \u2192 ( y : B) \u2192 C (x, y)) \u2192 ( x : prod A B) \u2192 C x := \\ C f (x, y) \u2192 f x y For example, in this way we can prove the propositional uniqueness principle, which says that every element of A \u00d7 B is equal to a pair. Specifically, we can construct a function #define prod-uniq ( A B : U) : ( x : prod A B) \u2192 (pr\u2081 A B x, pr\u2082 A B x) =_{prod A B} x := \\ (a, b) \u2192 refl _{(a, b)} Unit type \u00b6 Rzk has a built-in Unit type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book. Still, following the book, here is the recursor for the unit type: #define Unit-rec : ( C : U) \u2192 C \u2192 Unit \u2192 C := \\ _C c _unit \u2192 c And, similarly, the induction principle for the unit type: #define Unit-ind : ( C : Unit \u2192 U) \u2192 C unit \u2192 ( x : Unit) \u2192 C x := \\ _C c unit \u2192 c Induction enables us to prove the propositional uniqueness principle for Unit , which asserts that its only inhabitant is unit : #define Unit-uniq : ( x : Unit) \u2192 x = unit := Unit-ind ( \\ x \u2192 x = unit ) refl _{ unit } As mentioned above, this uniqueness principle is built into Rzk (making any value of type Unit definitionally equal to unit ), allowing to use refl immediately: #define Unit-uniq' : ( x : Unit) \u2192 x = unit := \\ _ \u2192 refl","title":"1.5 Product types"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/#15-product-types","text":"This is a literate Rzk file: #lang rzk-1 Rzk has built-in support for dependent pairs, so we define product types here in terms of those. #define prod ( A B : U) : U := \u03a3 ( _ : A), B To construct a pair, we can now simply use tuple syntax for \\(\\Sigma\\) -types: (a, b) . To use a pair, we can use pattern matching or introduce projections: #define pr\u2081 ( A B : U) : prod A B \u2192 A := \\ (a, _b) \u2192 a #define pr\u2082 ( A B : U) : prod A B \u2192 B := \\ (_a, b) \u2192 b The recursor for product types can be defined as follows: #define prod-rec ( A B : U) : ( C : U) \u2192 (A \u2192 B \u2192 C) \u2192 prod A B \u2192 C := \\ C f (a, b) \u2192 f a b Then instead of defining functions such as pr1 and pr2 directly by a defining equation, we could define #define pr\u2081' ( A B : U) : prod A B \u2192 A := prod-rec A B A ( \\ a _b \u2192 a) #define pr\u2082' ( A B : U) : prod A B \u2192 B := prod-rec A B B ( \\ _a b \u2192 b) To be able to define dependent functions over the product type, we have to generalize the recursor: #define prod-ind ( A B : U) : ( C : prod A B \u2192 U) \u2192 ( (x : A) \u2192 ( y : B) \u2192 C (x, y)) \u2192 ( x : prod A B) \u2192 C x := \\ C f (x, y) \u2192 f x y For example, in this way we can prove the propositional uniqueness principle, which says that every element of A \u00d7 B is equal to a pair. Specifically, we can construct a function #define prod-uniq ( A B : U) : ( x : prod A B) \u2192 (pr\u2081 A B x, pr\u2082 A B x) =_{prod A B} x := \\ (a, b) \u2192 refl _{(a, b)}","title":"1.5 Product types"},{"location":"1-foundations/1-type-theory/05-product-types.rzk/#unit-type","text":"Rzk has a built-in Unit type which behaves slightly differently from the unit type in the HoTT Book. In particular, in Rzk, uniqueness principle for the unit type is built in, making some proofs easier than in the book. Still, following the book, here is the recursor for the unit type: #define Unit-rec : ( C : U) \u2192 C \u2192 Unit \u2192 C := \\ _C c _unit \u2192 c And, similarly, the induction principle for the unit type: #define Unit-ind : ( C : Unit \u2192 U) \u2192 C unit \u2192 ( x : Unit) \u2192 C x := \\ _C c unit \u2192 c Induction enables us to prove the propositional uniqueness principle for Unit , which asserts that its only inhabitant is unit : #define Unit-uniq : ( x : Unit) \u2192 x = unit := Unit-ind ( \\ x \u2192 x = unit ) refl _{ unit } As mentioned above, this uniqueness principle is built into Rzk (making any value of type Unit definitionally equal to unit ), allowing to use refl immediately: #define Unit-uniq' : ( x : Unit) \u2192 x = unit := \\ _ \u2192 refl","title":"Unit type"},{"location":"1-foundations/1-type-theory/06-dependent-pair-types.rzk/","text":"1.6 Dependent pair types \u00b6 This is a literate Rzk file: #lang rzk-1","title":"1.6 Dependent pair types"},{"location":"1-foundations/1-type-theory/06-dependent-pair-types.rzk/#16-dependent-pair-types","text":"This is a literate Rzk file: #lang rzk-1","title":"1.6 Dependent pair types"},{"location":"1-foundations/1-type-theory/07-coproduct-types.rzk/","text":"1.7 Coproduct types \u00b6 Warning Coproduct types are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.7 Coproduct types"},{"location":"1-foundations/1-type-theory/07-coproduct-types.rzk/#17-coproduct-types","text":"Warning Coproduct types are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.7 Coproduct types"},{"location":"1-foundations/1-type-theory/08-booleans.rzk/","text":"1.8 The type of booleans \u00b6 Warning Booleans are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.8 The type of booleans"},{"location":"1-foundations/1-type-theory/08-booleans.rzk/#18-the-type-of-booleans","text":"Warning Booleans are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.8 The type of booleans"},{"location":"1-foundations/1-type-theory/09-natural-numbers.rzk/","text":"1.9 The natural numbers \u00b6 Warning Natural numbers (and user-defined data types) are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.9 The natural numbers"},{"location":"1-foundations/1-type-theory/09-natural-numbers.rzk/#19-the-natural-numbers","text":"Warning Natural numbers (and user-defined data types) are currently not supported in rzk. This is a literate Rzk file: #lang rzk-1","title":"1.9 The natural numbers"},{"location":"1-foundations/1-type-theory/10-pattern-matching-and-recursion.rzk/","text":"1.10 Pattern matching and recursion \u00b6 This is a literate Rzk file: #lang rzk-1","title":"1.10 Pattern matching and recursion"},{"location":"1-foundations/1-type-theory/10-pattern-matching-and-recursion.rzk/#110-pattern-matching-and-recursion","text":"This is a literate Rzk file: #lang rzk-1","title":"1.10 Pattern matching and recursion"},{"location":"1-foundations/1-type-theory/11-propositions-as-types.rzk/","text":"1.11 Propositions as types \u00b6 This is a literate Rzk file: #lang rzk-1","title":"1.11 Propositions as types"},{"location":"1-foundations/1-type-theory/11-propositions-as-types.rzk/#111-propositions-as-types","text":"This is a literate Rzk file: #lang rzk-1","title":"1.11 Propositions as types"},{"location":"1-foundations/1-type-theory/12-identity-types.rzk/","text":"1.11 Identity types \u00b6 This is a literate Rzk file: #lang rzk-1","title":"1.12 Identity types"},{"location":"1-foundations/1-type-theory/12-identity-types.rzk/#111-identity-types","text":"This is a literate Rzk file: #lang rzk-1","title":"1.11 Identity types"},{"location":"1-foundations/1-type-theory/exercises.rzk/","text":"Exercises for Section 1 \u00b6 Warning At the moment rzk typecheck does not check indented blocks, so solutions in this section (which are nested in admonitions) are not checked. This is a literate Rzk file: #lang rzk-1 Exercise 1.1 \u00b6 Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\) , define their composite \\(g \\circ f : A \\to C\\) . Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\) . Solution Solution to Exercise 1.1 #define compose ( A B C : U) ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 C := \\ x \u2192 g (f x)","title":"Exercises"},{"location":"1-foundations/1-type-theory/exercises.rzk/#exercises-for-section-1","text":"Warning At the moment rzk typecheck does not check indented blocks, so solutions in this section (which are nested in admonitions) are not checked. This is a literate Rzk file: #lang rzk-1","title":"Exercises for Section 1"},{"location":"1-foundations/1-type-theory/exercises.rzk/#exercise-11","text":"Given functions \\(f : A \\to B\\) and \\(g : B \\to C\\) , define their composite \\(g \\circ f : A \\to C\\) . Show that we have \\(h \\circ (g \\circ f) \\equiv (h \\circ g) \\circ f\\) . Solution Solution to Exercise 1.1 #define compose ( A B C : U) ( g : B \u2192 C) ( f : A \u2192 B) : A \u2192 C := \\ x \u2192 g (f x)","title":"Exercise 1.1"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/","text":"2.1 Types are higher groupoids \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.1 Types are higher groupoids"},{"location":"1-foundations/2-homotopy-type-theory/01-types-are-higher-groupoids.rzk/#21-types-are-higher-groupoids","text":"This is a literate Rzk file: #lang rzk-1","title":"2.1 Types are higher groupoids"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/","text":"2.2 Functions are functors \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.2 Functions are functors"},{"location":"1-foundations/2-homotopy-type-theory/02-functions-are-functors.rzk/#22-functions-are-functors","text":"This is a literate Rzk file: #lang rzk-1","title":"2.2 Functions are functors"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/","text":"2.3 Type families are fibrations \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.3 Type families are fibrations"},{"location":"1-foundations/2-homotopy-type-theory/03-type-families-are-fibrations.rzk/#23-type-families-are-fibrations","text":"This is a literate Rzk file: #lang rzk-1","title":"2.3 Type families are fibrations"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-are-equivalences.rzk/","text":"2.4 Homotopies are equivalences \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.4 Homotopies are equivalences"},{"location":"1-foundations/2-homotopy-type-theory/04-homotopies-are-equivalences.rzk/#24-homotopies-are-equivalences","text":"This is a literate Rzk file: #lang rzk-1","title":"2.4 Homotopies are equivalences"},{"location":"1-foundations/2-homotopy-type-theory/05-the-higher-groupoid-structure-of-type-formers.rzk/","text":"2.5 The higher groupoid structure of type formers \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.5 The higher groupoid structure of type formers"},{"location":"1-foundations/2-homotopy-type-theory/05-the-higher-groupoid-structure-of-type-formers.rzk/#25-the-higher-groupoid-structure-of-type-formers","text":"This is a literate Rzk file: #lang rzk-1","title":"2.5 The higher groupoid structure of type formers"},{"location":"1-foundations/2-homotopy-type-theory/06-cartesian-product-types.rzk/","text":"2.6 Cartesian product types \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.6 Cartesian product types"},{"location":"1-foundations/2-homotopy-type-theory/06-cartesian-product-types.rzk/#26-cartesian-product-types","text":"This is a literate Rzk file: #lang rzk-1","title":"2.6 Cartesian product types"},{"location":"1-foundations/2-homotopy-type-theory/07-sigma-types.rzk/","text":"2.7 \\(\\Sigma\\) -types \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.7 \u03a3-types"},{"location":"1-foundations/2-homotopy-type-theory/07-sigma-types.rzk/#27-sigma-types","text":"This is a literate Rzk file: #lang rzk-1","title":"2.7 \\(\\Sigma\\)-types"},{"location":"1-foundations/2-homotopy-type-theory/08-the-unit-type.rzk/","text":"2.8 The unit type \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.8 The unit type"},{"location":"1-foundations/2-homotopy-type-theory/08-the-unit-type.rzk/#28-the-unit-type","text":"This is a literate Rzk file: #lang rzk-1","title":"2.8 The unit type"},{"location":"1-foundations/2-homotopy-type-theory/09-pi-types-and-function-extensionality.rzk/","text":"2.9 \\(\\Pi\\) -types and the function extensionality axiom \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.9 \u03a0-types and the function extensionality axiom"},{"location":"1-foundations/2-homotopy-type-theory/09-pi-types-and-function-extensionality.rzk/#29-pi-types-and-the-function-extensionality-axiom","text":"This is a literate Rzk file: #lang rzk-1","title":"2.9 \\(\\Pi\\)-types and the function extensionality axiom"},{"location":"1-foundations/2-homotopy-type-theory/10-universes-and-univalence-axiom.rzk/","text":"2.10 Universes and univalence axiom \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.10 Universes and univalence axiom"},{"location":"1-foundations/2-homotopy-type-theory/10-universes-and-univalence-axiom.rzk/#210-universes-and-univalence-axiom","text":"This is a literate Rzk file: #lang rzk-1","title":"2.10 Universes and univalence axiom"},{"location":"1-foundations/2-homotopy-type-theory/11-identity-type.rzk/","text":"2.11 Identity type \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.11 Identity type"},{"location":"1-foundations/2-homotopy-type-theory/11-identity-type.rzk/#211-identity-type","text":"This is a literate Rzk file: #lang rzk-1","title":"2.11 Identity type"},{"location":"1-foundations/2-homotopy-type-theory/12-coproducts.rzk/","text":"2.12 Coproducts \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.12 Coproducts"},{"location":"1-foundations/2-homotopy-type-theory/12-coproducts.rzk/#212-coproducts","text":"This is a literate Rzk file: #lang rzk-1","title":"2.12 Coproducts"},{"location":"1-foundations/2-homotopy-type-theory/13-natural-numbers.rzk/","text":"2.13 Natural numbers \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.13 Natural numbers"},{"location":"1-foundations/2-homotopy-type-theory/13-natural-numbers.rzk/#213-natural-numbers","text":"This is a literate Rzk file: #lang rzk-1","title":"2.13 Natural numbers"},{"location":"1-foundations/2-homotopy-type-theory/14-example-equality-of-structures.rzk/","text":"2.14 Example: equality of structures \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.14 Example: equality of structures"},{"location":"1-foundations/2-homotopy-type-theory/14-example-equality-of-structures.rzk/#214-example-equality-of-structures","text":"This is a literate Rzk file: #lang rzk-1","title":"2.14 Example: equality of structures"},{"location":"1-foundations/2-homotopy-type-theory/15-universal-properties.rzk/","text":"2.15 Universal properties \u00b6 This is a literate Rzk file: #lang rzk-1","title":"2.15 Universal properties"},{"location":"1-foundations/2-homotopy-type-theory/15-universal-properties.rzk/#215-universal-properties","text":"This is a literate Rzk file: #lang rzk-1","title":"2.15 Universal properties"},{"location":"1-foundations/2-homotopy-type-theory/exercises.rzk/","text":"Exercises for Section 2 \u00b6 Warning At the moment rzk typecheck does not check indented blocks, so solutions in this section (which are nested in admonitions) are not checked. This is a literate Rzk file: #lang rzk-1","title":"Exercises"},{"location":"1-foundations/2-homotopy-type-theory/exercises.rzk/#exercises-for-section-2","text":"Warning At the moment rzk typecheck does not check indented blocks, so solutions in this section (which are nested in admonitions) are not checked. This is a literate Rzk file: #lang rzk-1","title":"Exercises for Section 2"}]}